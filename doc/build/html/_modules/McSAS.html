

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>McSAS &mdash; McSAS v1.0 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="McSAS v1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">McSAS v1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for McSAS</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">A class and supplementary functions for Monte-Carlo fitting of SAXS patterns. It is </span>
<span class="sd">released under a Creative Commons CC-BY-SA license. Please cite as:</span>

<span class="sd">Brian R. Pauw et al., J. Appl. Cryst. 46, (2013), pp. 365--371</span>
<span class="sd">    doi: http://dx.doi.org/10.1107/S0021889813001295</span>

<span class="sd">This file defines the following classes and functions: </span>
<span class="sd">    - McSAS: class containing all the functions required to perform a Monte Carlo analysis</span>
<span class="sd">        on small-angle scattering data.</span>
<span class="sd">    - binning_array: Can be used to do n-by-n pixel binning of 2D detector images. The </span>
<span class="sd">        returned uncertainty is the larger of either the binned uncertainty or the sample</span>
<span class="sd">        standard deviation in the bin.</span>
<span class="sd">    - binning_1D: bins the data and propagates errors, or calculates errors if not initially </span>
<span class="sd">        provided</span>
<span class="sd">    - binning_weighted_1D: Weighted binning, where the intensities of a pixel are divided </span>
<span class="sd">        between the two neighbouring bins depending on the distances to the centres. If </span>
<span class="sd">        error provided is empty, the standard deviation of the intensities in the bins are </span>
<span class="sd">        computed. </span>
<span class="sd">    - csqr: least-squares error to use with scipy.optimize.leastsq</span>
<span class="sd">    - Iopt: Optimize the scaling factor and background level of modeled data vs. intensity</span>
<span class="sd">    - csqr_v1: least-squares for data with known error, size of parameter-space not taken </span>
<span class="sd">        into account</span>
<span class="sd">    - Iopt_v1: old intensity scaling factor optimisation, more robust but slower than Iopt</span>
<span class="sd">    - pickle_read: Reads in pickled data from a file (by filename)</span>
<span class="sd">    - pickle_write: write a block or dictionary to a file (by filename)</span>
<span class="sd">    </span>
<span class="sd">Made possible with help from (amongst others):</span>
<span class="sd">    Samuel Tardif - Derivations (mostly observability) and checking of mathematics</span>
<span class="sd">    Jan Skov Pedersen - checking of mathematics</span>
<span class="sd">    Pawel Kwasniewski &lt;kwasniew@esrf.fr&gt; - Code cleanup and documentation</span>
<span class="sd">    Ingo Bressler &lt;ingo.bressler@bam.de&gt; - Code cleanup, modification and documentation</span>


<span class="sd">A note on units:</span>
<span class="sd">===========================</span>
<span class="sd">Internally, all length units are in meters, all angle units in degrees clockwise from </span>
<span class="sd">    top. Intensity is in 1/(m sr), q in 1/m. The electron density contrast squared,</span>
<span class="sd">    ``drhosqr`` is in m^-4. Other units may be used, but if absolute units are supplied </span>
<span class="sd">    and absolute volume fractions required, meters are necessitated.</span>



<span class="sd">Example usage:</span>
<span class="sd">===========================</span>
<span class="sd">        *for detailed usage, see accompanying documentation*</span>

<span class="sd">Fitting a single dataset using all automatic and default parameters (may go wrong on </span>
<span class="sd">poorly conditioned input, needs sensibly-spaced datapoints and good uncertainty </span>
<span class="sd">estimates). The dataset is considered to consist of three variables: Q, I and IERR::</span>
<span class="sd">    McSAS(Q=Q,I=I,IERR=IERR,Plot=True)</span>

<span class="sd">Optional parameters can be supplied in parameter-value pairs to finetune optimisation </span>
<span class="sd">behaviour::</span>
<span class="sd">    A=McSAS(Q=Q,I=I,IERR=numpy.maximum(0.01*I,E),Ncontrib=200,Convcrit=1,Bounds=array([0.5e-9,35e-9]),Maxiter=1e5,Histscale=&#39;log&#39;,drhosqr=1e30,Nreps=100,Plot=True)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">scipy</span> <span class="c"># For many important functions</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span> <span class="c"># For the leastsq optimization function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="c"># For arrays</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">inf</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">isfinite</span><span class="p">,</span> <span class="n">reshape</span><span class="p">,</span> <span class="n">prod</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span>
                  <span class="n">arange</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">logspace</span><span class="p">,</span> <span class="n">log10</span><span class="p">,</span>
                  <span class="n">isnan</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">os</span> <span class="c"># Miscellaneous operating system interfaces</span>
<span class="kn">import</span> <span class="nn">time</span> <span class="c"># Timekeeping and timing of objects</span>
<span class="kn">import</span> <span class="nn">sys</span> <span class="c"># For printing of slightly more advanced messages to stdout</span>
<span class="kn">import</span> <span class="nn">pickle</span> <span class="c">#for pickle_read and pickle_write</span>

<div class="viewcode-block" id="McSAS"><a class="viewcode-back" href="../code.html#McSAS.McSAS">[docs]</a><span class="k">class</span> <span class="nc">McSAS</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main class containing all functions required to do Monte Carlo fitting.</span>

<span class="sd">    Input:</span>
<span class="sd">    ------</span>
<span class="sd">    McSAS required parameters::</span>
<span class="sd">        - `Q`: a 1D or 2D array of q-values.</span>
<span class="sd">        - `I`: a similarly sized array of corresponding intensity values</span>
<span class="sd">        - `IERR`: a similarly sized array of corresponding intensity uncertainty values</span>
<span class="sd">    McSAS optional parameters::</span>
<span class="sd">        - `PSI` : 2D array </span>
<span class="sd">            detector angle values, only required for 2D pattern fitting.</span>
<span class="sd">        - `Bounds` : list</span>
<span class="sd">            Two-element vector or list indicating upper and lower size bounds of the </span>
<span class="sd">            particle radii used in the fitting procedure. If not provided, these will</span>
<span class="sd">            be estimated as: Rmax=pi/qmin and Rmin=pi/qmax. units: m</span>
<span class="sd">        - `Nsph` : int, default: 200</span>
<span class="sd">            Number of spheres used for the MC simulation</span>
<span class="sd">        - `Maxiter` : int, default: 1e5</span>
<span class="sd">            Maximum number of iterations for the MCfit_sph() function</span>
<span class="sd">        - `Rpfactor : float, default: 1.5/3</span>
<span class="sd">            Parameter used to compensate the volume^2 scaling of each sphere </span>
<span class="sd">            contribution to the simulated I(q)</span>
<span class="sd">        - `Nreps` : int, default: 100</span>
<span class="sd">            Number of repetitions of the MC fit for determination of final histogram </span>
<span class="sd">            uncertainty.</span>
<span class="sd">        - `qlims` : list, default: [0,inf]</span>
<span class="sd">            Limits on the fitting range in q. units: m^-1</span>
<span class="sd">        - `Histbins` : int, default: 50</span>
<span class="sd">            Number of bins used for the histogramming procedure.</span>
<span class="sd">        - `Histscale` : string, default: &#39;log&#39;</span>
<span class="sd">            Can be set to &#39;log&#39; for histogramming on a logarithmic size scale, </span>
<span class="sd">            recommended for q- and/or size-ranges spanning more than a decade.</span>
<span class="sd">        - `Histweight` : string, default: &#39;volume&#39;</span>
<span class="sd">            Can be set to &#39;number&#39; to force plotting of number-weighted distributions</span>
<span class="sd">            2013-03-19 issue remains that the observability in this case is incorrect.</span>
<span class="sd">        - `drhosqr` : float, default: 1</span>
<span class="sd">            Scattering contrast - when known it will be used to calculate the absolute</span>
<span class="sd">            volume fraction of each contribution, units: m^-4</span>
<span class="sd">        - `Convcrit` : float, default: 1</span>
<span class="sd">            Convergence criterion for the least-squares fit. The fit converges once </span>
<span class="sd">            the normalized chi squared &lt; Convcrit. If convergence is reached with </span>
<span class="sd">            Convcrit = 1, the model describes the data (on average) to within the </span>
<span class="sd">            uncertainty, and thus all information has been extracted from the </span>
<span class="sd">            scattering pattern.</span>
<span class="sd">        - `StartFromMin` : bool, default: False</span>
<span class="sd">            If set to False, the starting configuration is a set of spheres with radii</span>
<span class="sd">            uniformly sampled between the given or estimated bounds.</span>
<span class="sd">            If set to True, the starting configuration is a set of spheres with radii</span>
<span class="sd">            set to the lower given or estimated Bound (if not zero). Practically, this</span>
<span class="sd">            makes little difference and this feature might be depreciated.</span>
<span class="sd">        - `Maxntry` : int, default: 5</span>
<span class="sd">            If a single MC optimization fails to reach convergence within Maxiter, it</span>
<span class="sd">            may just be due to bad luck. The Analyze_1D procedure will try to redo </span>
<span class="sd">            that MC optimization for a maximum of Maxntry tries before concluding that</span>
<span class="sd">            it is not bad luck but bad input.</span>
<span class="sd">        - `Plot` : Bool, default: False</span>
<span class="sd">            If set to True, will generate a plot showing the data and fit, as well as</span>
<span class="sd">            the resulting size histogram.</span>
<span class="sd">        - `Memsave`: Bool, default: False</span>
<span class="sd">            For 2D pattern fitting, or for fitting patterns with a very large number </span>
<span class="sd">            of datapoints or contributions, it may make sense to turn this option on </span>
<span class="sd">            in order for intensity generating functions not to take up much memory.</span>
<span class="sd">            The cost for this is perhaps a 20-ish percent reduction in speed.</span>
<span class="sd">        - `BOUNDS` : string</span>
<span class="sd">            the McSAS function to use for calculating random number generator </span>
<span class="sd">            bounds based on input (f.ex. q and I). default: SphBounds</span>
<span class="sd">        - `FF` : string</span>
<span class="sd">            the McSAS function to use for calculating the form factors.</span>
<span class="sd">            default: FF_sph_1D </span>
<span class="sd">        - `RAND` : string</span>
<span class="sd">            the McSAS function to use for generating random numbers</span>
<span class="sd">            default: random_uniform_sph</span>
<span class="sd">        - `SMEAR` : string</span>
<span class="sd">            the McSAS function to use for smearing of intensity</span>
<span class="sd">            default: _passthrough</span>
<span class="sd">        - `VOL` : string</span>
<span class="sd">            the McSAS function to use for calculating the base object volume</span>
<span class="sd">            default: vol_sph</span>

<span class="sd">    Returns:</span>
<span class="sd">    -------</span>
<span class="sd">    A : Output dictionary containing the following elements:</span>
<span class="sd">        &#39;Imean&#39; : 1D array </span>
<span class="sd">            The fitted intensity, given as the mean of all Nreps results.</span>
<span class="sd">        &#39;q&#39; : 1D array</span>
<span class="sd">            Corresponding q values (may be different than the input q if qlims was </span>
<span class="sd">            used) </span>
<span class="sd">        &#39;Istd&#39; : array</span>
<span class="sd">            Standard deviation of the fitted I(q), calculated as the standard </span>
<span class="sd">            deviation of all Nreps results.</span>
<span class="sd">        &#39;Hx&#39; : array</span>
<span class="sd">            Histogram bin left edge position</span>
<span class="sd">        &#39;Hmid&#39; : array</span>
<span class="sd">            Center positions for the size histogram bins</span>
<span class="sd">        &#39;Hwidth&#39; : array</span>
<span class="sd">            Histogram bin width</span>
<span class="sd">        &#39;Hmean&#39; : array</span>
<span class="sd">            Volume-weighted particle size distribution values for all Nreps results</span>
<span class="sd">        &#39;Hstd&#39; : array</span>
<span class="sd">            Standard deviations of the corresponding size distribution bins, calculated</span>
<span class="sd">            from Nreps repetitions of the MCfit_sph() function</span>
<span class="sd">        &#39;Hy&#39; : size (Histbins x Nreps) array</span>
<span class="sd">            Volume-weighted particle size distribution values for each MC fit repetition</span>
<span class="sd">        &#39;Niter&#39; : int</span>
<span class="sd">            Average number of MC iterations required for convergence</span>
<span class="sd">        &#39;Rrep&#39; : size (Nsph x Nreps) array</span>
<span class="sd">            Collection of Nsph sphere radii fitted to best represent the provided I(q) data.</span>
<span class="sd">            Contains the results of each of Nreps iterations. This can be used for</span>
<span class="sd">            rebinning without having to re-optimize.</span>
<span class="sd">        &#39;Vf&#39; : size (Nsph x Nreps) array</span>
<span class="sd">            Volume fractions for each of Nsph spheres </span>
<span class="sd">            in each of Nreps iterations</span>
<span class="sd">        &#39;Vft&#39; : size (Nreps) array</span>
<span class="sd">            Total scatterer volume fraction for each of the Nreps iterations </span>
<span class="sd">        &#39;vfmin&#39; : size (Nsph x Nreps) array</span>
<span class="sd">            minimum required volube fraction for each contribution to become statistically</span>
<span class="sd">            significant.</span>
<span class="sd">        &#39;vfminbins&#39; : size (Hmid) array </span>
<span class="sd">            array with the minimum required volume fraction per bin to become statistically </span>
<span class="sd">            significant. Used to display minimum required level in histogram.</span>
<span class="sd">        &#39;Screps&#39; : size (2 x Nreps) array</span>
<span class="sd">            Scaling and background values for each repetition. Used to display background </span>
<span class="sd">            level in data and fit plot.</span>
<span class="sd">    &quot;&quot;&quot;</span>        

    <span class="n">dataset</span><span class="o">=</span><span class="bp">None</span> <span class="c">#where Q, PSI, I and IERR is stored, original dataset</span>
    <span class="n">fitdata</span><span class="o">=</span><span class="bp">None</span> <span class="c">#may be populated with a subset of the aforementioned dataset, limited to q-limits or psi limits and to positive I values alone</span>
    <span class="n">parameters</span><span class="o">=</span><span class="bp">None</span> <span class="c">#where the fitting and binning settings are stored</span>
    <span class="n">result</span><span class="o">=</span><span class="bp">None</span> <span class="c">#where all the analysis results are stored, I do not think this needs separation after all into results of analysis and results of interpretation. However, this is a list of dicts, one per variable (as the method, especially for 2D analysis, can deal with more than one random values. analysis results are stored along with the histogrammed results of the first variable with index [0]:</span>
    <span class="n">functions</span><span class="o">=</span><span class="bp">None</span> <span class="c">#where the used functions are defined, this is where shape changes, smearing, and various forms of integrations are placed.</span>
    <span class="n">calcdata</span><span class="o">=</span><span class="bp">None</span> <span class="c">#here values and matrices are stored used by the calculations.</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        intialization function, input kwargs can be aforementioend parameter keyword-value pairs.</span>
<span class="sd">        This does the following::</span>
<span class="sd">            1. Initialises the variables to the right type</span>
<span class="sd">            2. Parses the input</span>
<span class="sd">            3. Stores the supplied data twice, one original and one for fitting </span>
<span class="sd">                (the latter of which may be clipped or otherwise adjusted)</span>
<span class="sd">            4. Applies Q- and optional PSI- limits to the data</span>
<span class="sd">            5. Reshapes fitdata to 1-by-n dimensions</span>
<span class="sd">            6. Sets the function references</span>
<span class="sd">            7. Calculates the shape parameter bounds if not supplied</span>
<span class="sd">            8. Peforms simple checks on validity of input</span>
<span class="sd">            9. Runs the Analyse() function which applies the MC fit multiple times</span>
<span class="sd">            10. Runs the Histogram() procedure which processes the MC result </span>
<span class="sd">            11. Optionally recalculates the resulting intensity in the same shape </span>
<span class="sd">                as the original (for 2D datasets)</span>
<span class="sd">            12. Optionally displays the results graphically.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span> <span class="c">#where Q, PSI, I and IERR is stored, original dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span> <span class="c">#may be populated with a subset of the aforementioned dataset, limited to q-limits or psi limits and to positive I values alone</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span> <span class="c">#where the fitting and binning settings are stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span> <span class="c">#where all the analysis results are stored, I do not think this needs separation after all into results of analysis and results of interpretation. However, this is a list of dicts, one per variable (as the method, especially for 2D analysis, can deal with more than one random values. analysis results are stored along with the histogrammed results of the first variable with index [0]:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">())</span>
        <span class="c">#self.analysisresult=dict() #The place where the raw analysis details are stored, along with qfit and Ifit.</span>
        <span class="c">#self.interpretresult=dict() #The place for the histogrammed data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span> <span class="c">#where the used functions are defined, this is where shape changes, smearing, and various forms of integrations are placed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calcdata</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span> <span class="c">#here values and matrices are stored used by the calculations.</span>
        <span class="c">#self.handles=dict() #I don&#39;t think handles can be stored in a dict.</span>

        <span class="c">#populate self with defaults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_defaults</span><span class="p">()</span>
        <span class="c">#set supplied kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="c">#passing on kwargs</span>
        <span class="c">#set data values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setdata</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c">#apply q and psi limits and populate self.fitdata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_dataset</span><span class="p">()</span>
        <span class="c">#reshape fitdata to the correct 1-by-n dimensions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reshape_fitdata</span><span class="p">()</span>
        <span class="c">#apply input settings for fitting, setting the required function definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setfunctions</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c">#calculate parameter bounds and store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;BOUNDS&#39;</span><span class="p">]()</span>
        <span class="c">#check and fix parameters where necessary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_parameters</span><span class="p">()</span> <span class="c">#this is only a very simple function now in need of expansion</span>

        <span class="c">#Analyse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Analyse</span><span class="p">()</span>

        <span class="c">##Histogram</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Histogram</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;Q&#39;</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="c">#2D mode, regenerate intensity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">TwoDGenI</span><span class="p">()</span>

        <span class="c">##Plot</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Plot&#39;</span><span class="p">):</span>
            <span class="c">#Odata=self.getdata(dataset=&#39;original&#39;)</span>
            <span class="c">#Result=self.getresult()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Plot</span><span class="p">()</span>

<div class="viewcode-block" id="McSAS.TwoDGenI"><a class="viewcode-back" href="../code.html#McSAS.McSAS.TwoDGenI">[docs]</a>    <span class="k">def</span> <span class="nf">TwoDGenI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this function is optionally run after the histogram procedure for anisotropic images, and will calculate the MC fit intensity in imageform</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">()</span>
        <span class="c">#load original dataset</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        <span class="n">I</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        <span class="n">E</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;IERR&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        <span class="n">PSI</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;PSI&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        <span class="c">#we need to recalculate the result in two dimensions</span>
        <span class="n">kansas</span><span class="o">=</span><span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="c">#we will return to this shape</span>
        <span class="n">q</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c">#flatten</span>
        <span class="n">I</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">I</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c">#flatten</span>
        <span class="n">E</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">E</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c">#flatten</span>
        <span class="n">PSI</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">PSI</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c">#flatten</span>

        <span class="n">Randfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;RAND&#39;</span><span class="p">]</span>
        <span class="n">FFfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;FF&#39;</span><span class="p">]</span>
        <span class="n">VOLfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;VOL&#39;</span><span class="p">]</span>
        <span class="n">SMEARfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;SMEAR&#39;</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&#39;Recalculating final result, this may take some time&#39;</span>
        <span class="c">#for each result</span>
        <span class="n">Iave</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">Nreps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Nreps&#39;</span><span class="p">)</span>
        <span class="n">Rpfactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Rpfactor&#39;</span><span class="p">)</span>
        <span class="n">qlims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;qlims&#39;</span><span class="p">)</span>
        <span class="n">psilims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;psilims&#39;</span><span class="p">)</span>
        <span class="n">Memsave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Memsave&#39;</span><span class="p">)</span>
        <span class="n">Ncontrib</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Ncontrib&#39;</span><span class="p">)</span>
        <span class="n">Screps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Screps&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nreps</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&#39;regenerating set {} of {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span><span class="n">Nreps</span><span class="p">)</span>
            <span class="n">Rset</span><span class="o">=</span><span class="n">Result</span><span class="p">[</span><span class="s">&#39;Rrep&#39;</span><span class="p">][:,:,</span><span class="n">nr</span><span class="p">]</span>
            <span class="c">#calculate their form factors</span>
            <span class="n">Vset</span><span class="o">=</span><span class="n">VOLfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="p">)</span>
            <span class="c">#Vset=(4.0/3*pi)*Rset**(3*Rpfactor)</span>
            <span class="c">#calculate the intensities</span>
            <span class="k">if</span> <span class="n">Memsave</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
                <span class="n">FFset</span> <span class="o">=</span> <span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="n">Q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span><span class="n">PSI</span><span class="o">=</span><span class="n">PSI</span><span class="p">)</span> <span class="c">#Form factors, all normalized to 1 at q=0.</span>
                <span class="c"># Calculate the intensities</span>
                <span class="n">Iset</span> <span class="o">=</span> <span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Intensity for each contribution as used in the MC calculation</span>
                <span class="n">It</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c"># the total intensity of the scattering pattern</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="mi">0</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:],</span><span class="n">Q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span><span class="n">PSI</span><span class="o">=</span><span class="n">PSI</span><span class="p">)</span>
                <span class="n">It</span><span class="o">=</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
                <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Ncontrib</span><span class="p">):</span>
                    <span class="c">#calculate their form factors</span>
                    <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="n">ri</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:],</span><span class="n">Q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span><span class="n">PSI</span><span class="o">=</span><span class="n">PSI</span><span class="p">)</span>
                    <span class="n">It</span><span class="o">=</span><span class="n">It</span><span class="o">+</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
            <span class="n">Vst</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c"># total volume squared</span>
            <span class="n">It</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">It</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c"># reshaped to match I and q</span>
            <span class="c"># Optimize the intensities and calculate convergence criterium</span>
            <span class="c">#SMEAR function goes here</span>
            <span class="n">It</span><span class="o">=</span><span class="n">SMEARfunc</span><span class="p">(</span><span class="n">It</span><span class="p">)</span>
            <span class="n">Iave</span><span class="o">=</span><span class="n">Iave</span><span class="o">+</span><span class="n">It</span><span class="o">*</span><span class="n">Screps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">nr</span><span class="p">]</span><span class="o">+</span><span class="n">Screps</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nr</span><span class="p">]</span> <span class="c">#add to average</span>
        <span class="c">#print &quot;Initial conval V1&quot;,Conval1</span>
        <span class="n">Iave</span><span class="o">=</span><span class="n">Iave</span><span class="o">/</span><span class="n">Nreps</span>
        <span class="c">#mask (lifted from clip_dataset)</span>
        <span class="n">validbools</span><span class="o">=</span><span class="n">isfinite</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="c"># Optional masking of negative intensity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;MaskNegI&#39;</span><span class="p">):</span>
            <span class="n">validbools</span><span class="o">=</span><span class="n">validbools</span><span class="o">*</span><span class="p">(</span><span class="n">I</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qlims</span><span class="o">==</span><span class="p">[])</span><span class="ow">and</span><span class="p">(</span><span class="n">psilims</span><span class="o">==</span><span class="p">[]):</span>
            <span class="c">#q limits not set, simply copy dataset to fitdata</span>
            <span class="n">validbools</span><span class="o">=</span><span class="n">validbools</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="n">qlims</span><span class="o">==</span><span class="p">[])):</span> <span class="c">#and qlims is implicitly set</span>
            <span class="n">validbools</span> <span class="o">=</span> <span class="n">validbools</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">qlims</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">qlims</span><span class="p">))</span> <span class="c">#excluding the lower q limit may prevent q=0 from appearing</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="n">psilims</span><span class="o">==</span><span class="p">[])):</span> <span class="c">#we assume here that we have a dataset [&#39;PSI&#39;]</span>
            <span class="n">validbools</span> <span class="o">=</span> <span class="n">validbools</span><span class="o">*</span><span class="p">(</span><span class="n">PSI</span><span class="o">&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psilims</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">PSI</span><span class="o">&lt;=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psilims</span><span class="p">))</span> <span class="c">#excluding the lower q limit may prevent q=0 from appearing</span>
        <span class="n">Iave</span><span class="o">=</span><span class="n">Iave</span><span class="o">*</span><span class="n">validbools</span>
        <span class="c">#shape back to imageform</span>
        <span class="n">I2D</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">Iave</span><span class="p">,</span><span class="n">kansas</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setresult</span><span class="p">(</span><span class="n">I2D</span><span class="o">=</span><span class="n">I2D</span><span class="p">)</span>

    </div>
<div class="viewcode-block" id="McSAS.setfunctions"><a class="viewcode-back" href="../code.html#McSAS.McSAS.setfunctions">[docs]</a>    <span class="k">def</span> <span class="nf">setfunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;functions are defined here. </span>
<span class="sd">        In particular here the following is specified:</span>
<span class="sd">        -1. The parameter bounds estimation function &#39;BOUNDS&#39;. Should be able to take input argument Bounds to update, should set the parameter bounds in self.parameter[&#39;Bounds&#39;]</span>
<span class="sd">        0. The random number generation function &#39;RAND&#39; This must take its parameters from self, and have an optional input argument specifying the number of sets to return (for MC initialization). It should return a set of Nsets-by-nvalues to be used directly in &#39;FF&#39;</span>
<span class="sd">        1. The Form-factor function &#39;FF&#39;. If called, this should get the required information from self and a supplied Nsets-by-nvalues shape-specifying parameter array. It should return an Nsets-by-q array. Orientational averaging should be part of the form-factor function (as it is most efficiently calculated there), so several form factor functions can exist for non-spherical objects.</span>
<span class="sd">        2. The shape volume calculation function &#39;VOL&#39;, which must be able to deal with input argument &quot;Rpfactor&quot;, ranging from 0 to 1. Should accept an Nsets-by-nvalues array returning an Nsets number of (Rpfactor-compensated)-volumes. </span>
<span class="sd">        3. The smearing function &#39;SMEAR&#39;. Should take information from self, and an input Icalc, to output an Ismear of the same length.</span>

<span class="sd">        This function will actually cast the supplied function name into a function pointer.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#make it into a function handle/pointer</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="McSAS.Analyse"><a class="viewcode-back" href="../code.html#McSAS.McSAS.Analyse">[docs]</a>    <span class="k">def</span> <span class="nf">Analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#get data</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span>
        <span class="n">I</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
        <span class="n">E</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;IERR&#39;</span><span class="p">)</span>
        <span class="c">#get settings</span>
        <span class="n">Priors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Priors&#39;</span><span class="p">)</span>
        <span class="n">Prior</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Prior&#39;</span><span class="p">)</span>
        <span class="n">Ncontrib</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Ncontrib&#39;</span><span class="p">)</span>
        <span class="n">Nreps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Nreps&#39;</span><span class="p">)</span>
        <span class="n">Convcrit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Convcrit&#39;</span><span class="p">)</span>
        <span class="n">Maxntry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Maxntry&#39;</span><span class="p">)</span>
        <span class="c">#find out how many values a shape is defined by:</span>
        <span class="n">testR</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;RAND&#39;</span><span class="p">]()</span>
        <span class="n">NRval</span><span class="o">=</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">((</span><span class="n">testR</span><span class="p">)))</span>

        <span class="n">Rrep</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Ncontrib</span><span class="p">,</span><span class="n">NRval</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span> 
        <span class="c">#DEBUG:</span>
        <span class="c">#print &#39;Rrep: {}&#39;.format(shape(Rrep))</span>
        <span class="n">Niters</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Nreps</span><span class="p">])</span>
        <span class="n">Irep</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">I</span><span class="p">)),</span><span class="n">Nreps</span><span class="p">])</span>
        <span class="n">bignow</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="c">#for time estimation and reporting</span>

        <span class="c">#This is the loop that repeats the MC optimization Nreps times, after which we can calculate an uncertainty on the results.</span>
        <span class="n">priorsflag</span><span class="o">=</span><span class="bp">False</span>
        <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nreps</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">Prior</span><span class="o">==</span><span class="p">[])</span><span class="ow">and</span><span class="p">(</span><span class="n">Priors</span><span class="o">!=</span><span class="p">[]))</span><span class="ow">or</span><span class="p">(</span><span class="n">priorsflag</span><span class="o">==</span><span class="bp">True</span><span class="p">):</span>
                <span class="n">priorsflag</span><span class="o">=</span><span class="bp">True</span> <span class="c">#this flag needs to be set as prior will be set after the first pass</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="n">Prior</span><span class="o">=</span><span class="n">Priors</span><span class="p">[:,:,</span><span class="n">nr</span><span class="o">%</span><span class="n">size</span><span class="p">(</span><span class="n">Priors</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
            <span class="n">nt</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#keep track of how many failed attempts there have been </span>
            <span class="c"># do that MC thing! </span>
            <span class="n">ConVal</span><span class="o">=</span><span class="n">inf</span>
            <span class="k">while</span> <span class="n">ConVal</span><span class="o">&gt;</span><span class="n">Convcrit</span><span class="p">:</span>
                <span class="c">#retry in the case we were unlucky in reaching convergence within Maxiter.</span>
                <span class="n">nt</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">Rrep</span><span class="p">[:,:,</span><span class="n">nr</span><span class="p">],</span><span class="n">Irep</span><span class="p">[:,:,</span><span class="n">nr</span><span class="p">],</span><span class="n">ConVal</span><span class="p">,</span><span class="n">Details</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">MCFit</span><span class="p">(</span><span class="n">OutputI</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">OutputDetails</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nt</span><span class="o">&gt;</span><span class="n">Maxntry</span><span class="p">:</span>
                    <span class="c">#this is not a coincidence. We have now tried Maxntry+2 times</span>
                    <span class="k">print</span> <span class="s">&quot;could not reach optimization criterion within {0} attempts, exiting...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Maxntry</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
                    <span class="k">return</span>
            <span class="n">Niters</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span> <span class="o">=</span> <span class="n">Details</span><span class="p">[</span><span class="s">&#39;Niter&#39;</span><span class="p">]</span> <span class="c">#keep track of how many iterations were needed to reach convergence</span>

            <span class="n">biglap</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="c">#time management</span>
            <span class="c"># in minutes:</span>
            <span class="n">tottime</span> <span class="o">=</span> <span class="p">(</span><span class="n">biglap</span><span class="o">-</span><span class="n">bignow</span><span class="p">)</span><span class="o">/</span><span class="mf">60.</span> <span class="c">#total elapsed time</span>
            <span class="n">avetime</span> <span class="o">=</span> <span class="p">(</span><span class="n">tottime</span><span class="o">/</span><span class="p">(</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c">#average time per MC optimization</span>
            <span class="n">remtime</span> <span class="o">=</span> <span class="p">(</span><span class="n">avetime</span><span class="o">*</span><span class="n">Nreps</span><span class="o">-</span><span class="n">tottime</span><span class="p">)</span> <span class="c">#estimated remaining time</span>
            <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">*finished optimization number {0} of {1} </span><span class="se">\r\n\t</span><span class="s">*total elapsed time: {2} minutes </span><span class="se">\r\n\t</span><span class="s">*average time per optimization {3} minutes </span><span class="se">\r\n\t</span><span class="s">*total time remaining {4} minutes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Nreps</span><span class="p">,</span><span class="n">tottime</span><span class="p">,</span><span class="n">avetime</span><span class="p">,</span><span class="n">remtime</span><span class="p">)</span>
        
        <span class="c">#at this point, all MC optimizations have been completed and we can process all Nreps results.</span>
        <span class="n">Imean</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Irep</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c">#mean fitted intensity</span>
        <span class="n">Istd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Irep</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c">#standard deviation on the fitted intensity, usually not plotted for clarity</span>
        <span class="c"># store in output dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setresult</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
            <span class="s">&#39;Rrep&#39;</span><span class="p">:</span><span class="n">Rrep</span><span class="p">,</span>
            <span class="s">&#39;Imean&#39;</span><span class="p">:</span><span class="n">Imean</span><span class="p">,</span>
            <span class="s">&#39;Istd&#39;</span><span class="p">:</span><span class="n">Istd</span><span class="p">,</span>
            <span class="s">&#39;Qfit&#39;</span><span class="p">:</span><span class="n">q</span><span class="p">,</span><span class="c"># can be obtained from self.fitdata </span>
            <span class="s">&#39;Niter&#39;</span><span class="p">:</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Niters</span><span class="p">)})</span> <span class="c">#average number of iterations for all repetitions</span>

    <span class="c">###########################################################################################</span>
    <span class="c">###################################### Histogram ##########################################</span>
    <span class="c">###########################################################################################</span></div>
<div class="viewcode-block" id="McSAS.Histogram"><a class="viewcode-back" href="../code.html#McSAS.McSAS.Histogram">[docs]</a>    <span class="k">def</span> <span class="nf">Histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Observability calculation for a series of spheres, over a range of q. </span>
<span class="sd">        Additional intensity and errors may be supplied for error-weighted observability. </span>
<span class="sd">        Intensity is used for determining the intesity scaling and background levels.</span>
<span class="sd">        </span>
<span class="sd">        Now with rebinning as well, so we can keep track of which contribution ends up in </span>
<span class="sd">        which bin and calculate the correct minimum required contribution accordingly.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#get settings</span>
        <span class="c">#set the bin edges for our radius bins either based on a linear division or on a logarithmic division of radii.</span>
        <span class="n">Ncontrib</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Ncontrib&#39;</span><span class="p">)</span>
        <span class="n">Nreps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Nreps&#39;</span><span class="p">)</span>
        <span class="n">Rpfactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Rpfactor&#39;</span><span class="p">)</span>
        <span class="n">Memsave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Memsave&#39;</span><span class="p">)</span>
        <span class="n">drhosqr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;drhosqr&#39;</span><span class="p">)</span>
        <span class="n">Rrep</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Rrep&#39;</span><span class="p">)</span>
        <span class="n">Histbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histbins&#39;</span><span class="p">)</span>
        <span class="n">Histscale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histscale&#39;</span><span class="p">)</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span>

        <span class="c">#ov = zeros(shape(Rrep)) #observability</span>
        <span class="n">Vf</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Ncontrib</span><span class="p">,</span><span class="n">Nreps</span><span class="p">))</span> <span class="c">#volume fraction for each contribution</span>
        <span class="n">Nf</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Ncontrib</span><span class="p">,</span><span class="n">Nreps</span><span class="p">))</span> <span class="c">#number fraction for each contribution</span>
        <span class="n">qm</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Ncontrib</span><span class="p">,</span><span class="n">Nreps</span><span class="p">))</span> <span class="c">#volume fraction for each contribution</span>
        <span class="n">vfmin</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Ncontrib</span><span class="p">,</span><span class="n">Nreps</span><span class="p">))</span> <span class="c">#volume fraction for each contribution</span>
        <span class="n">nfmin</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">Ncontrib</span><span class="p">,</span><span class="n">Nreps</span><span class="p">))</span> <span class="c">#number fraction for each contribution</span>
        <span class="n">Vft</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Nreps</span><span class="p">])</span> <span class="c">#total volume fractions</span>
        <span class="n">Nft</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Nreps</span><span class="p">])</span> <span class="c">#total number </span>
        <span class="n">Screps</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span> <span class="c">#Intensity scaling factors for matching to the experimental scattering pattern (Amplitude A and flat background term b, defined in the paper)</span>

        <span class="c">#functions!</span>
        <span class="n">Randfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;RAND&#39;</span><span class="p">]</span>
        <span class="n">FFfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;FF&#39;</span><span class="p">]</span>
        <span class="n">VOLfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;VOL&#39;</span><span class="p">]</span>
        <span class="n">SMEARfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;SMEAR&#39;</span><span class="p">]</span>

        <span class="c">#data!</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span>
        <span class="n">I</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
        <span class="n">E</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;IERR&#39;</span><span class="p">)</span>

        <span class="c">#loop over each repetition</span>
        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nreps</span><span class="p">):</span>
            <span class="n">Rset</span> <span class="o">=</span> <span class="n">Rrep</span><span class="p">[:,:,</span><span class="n">ri</span><span class="p">]</span> <span class="c">#the single set of R for this calculation</span>
            <span class="n">Vset</span> <span class="o">=</span> <span class="n">VOLfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="p">)</span> <span class="c">#compensated volume for each sphere in the set</span>
            <span class="k">if</span> <span class="n">Memsave</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
                <span class="n">FFset</span> <span class="o">=</span> <span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">)</span> <span class="c">#Form factors, all normalized to 1 at q=0.</span>
                <span class="c"># Calculate the intensities</span>
                <span class="n">Iset</span> <span class="o">=</span> <span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Intensity for each contribution as used in the MC calculation</span>
                <span class="n">It</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c"># the total intensity of the scattering pattern</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="mi">0</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:])</span>
                <span class="n">It</span><span class="o">=</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
                <span class="k">for</span> <span class="n">Rr</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Ncontrib</span><span class="p">):</span>
                    <span class="c">#calculate their form factors</span>
                    <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="n">Rr</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:])</span>
                    <span class="n">It</span><span class="o">=</span><span class="n">It</span><span class="o">+</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[</span><span class="n">Rr</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>

            <span class="n">Vst</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c"># total compensated volume squared </span>
            <span class="n">It</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">It</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">It</span><span class="p">))))</span>
            <span class="n">It</span><span class="o">=</span><span class="n">SMEARfunc</span><span class="p">(</span><span class="n">It</span><span class="p">)</span>
            
            <span class="c"># Now for each sphere, calculate its volume fraction (p_c compensated):</span>
            <span class="n">Vsa</span><span class="o">=</span><span class="n">VOLfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="p">)</span> <span class="c">#compensated volume for each sphere in the set Vsa = 4./3*pi*Rset**(3*Rpfactor)</span>
            <span class="c"># And the real particle volume:</span>
            <span class="n">Vpa</span><span class="o">=</span><span class="n">VOLfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span> <span class="c">#compensated volume for each sphere in the set Vsa = 4./3*pi*Rset**(3*Rpfactor)</span>

            <span class="n">Sci</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">It</span><span class="p">)</span> <span class="c">#initial guess for the scaling factor.</span>
            <span class="n">Bgi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
            <span class="n">Sc</span><span class="p">,</span><span class="n">Cv</span> <span class="o">=</span> <span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">It</span><span class="p">,</span><span class="n">E</span><span class="p">,[</span><span class="n">Sci</span><span class="p">,</span><span class="n">Bgi</span><span class="p">])</span> <span class="c">#optimize scaling and background for this repetition</span>
            <span class="n">Screps</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span><span class="o">=</span><span class="n">Sc</span> <span class="c">#scaling and background for this repetition.</span>
            <span class="n">Vf</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Vsa</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">Vpa</span><span class="o">*</span><span class="n">drhosqr</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="c"># a set of volume fractions</span>
            <span class="n">Vft</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Vf</span><span class="p">[:,</span><span class="n">ri</span><span class="p">])</span> <span class="c"># total volume </span>
            <span class="n">Nf</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">Vf</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">Vpa</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="c">#</span>
            <span class="n">Nft</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nf</span><span class="p">[:,</span><span class="n">ri</span><span class="p">])</span> <span class="c"># total number</span>
            <span class="k">for</span> <span class="n">isi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Ncontrib</span><span class="p">):</span> <span class="c">#For each sphere</span>
                <span class="c">#ov[isi,ri] = (Iset[isi,:]/(It)).max() #calculate the observability (the maximum contribution for that sphere to the total scattering pattern) NOTE: no need to compensate for p_c here, we work with volume fraction later which is compensated by default. additionally, we actually do not use this value.</span>
                <span class="k">if</span> <span class="n">Memsave</span><span class="p">:</span>
                    <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="n">isi</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:])</span>
                    <span class="n">Ir</span><span class="o">=</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[</span><span class="n">isi</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                    <span class="n">qmi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Ir</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">/</span><span class="n">It</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="c">#determine where this maximum observability is of contribution isi (index)</span>
                    <span class="n">qm</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">qmi</span><span class="p">]</span> <span class="c">#point where the contribution of isi is maximum</span>
                    <span class="n">vfmin</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">Vf</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ir</span><span class="p">))</span>
                    <span class="n">nfmin</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">vfmin</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span><span class="o">/</span><span class="n">Vpa</span><span class="p">[</span><span class="n">isi</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">qmi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Iset</span><span class="p">[</span><span class="n">isi</span><span class="p">,:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">/</span><span class="n">It</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="c">#determine where this maximum observability is of contribution isi (index)</span>
                    <span class="n">qm</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">qmi</span><span class="p">]</span> <span class="c">#point where the contribution of isi is maximum</span>
                    <span class="n">vfmin</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">Vf</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Iset</span><span class="p">[</span><span class="n">isi</span><span class="p">,:]))</span>
                    <span class="n">nfmin</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">vfmin</span><span class="p">[</span><span class="n">isi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span><span class="o">/</span><span class="n">Vpa</span><span class="p">[</span><span class="n">isi</span><span class="p">]</span>
                <span class="c">#close approximation:</span>
                <span class="c">#vfmin[isi,ri] = (E[qmi]*Vf[isi,ri]/(Sc[0]*Iset[isi,qmi]))</span>
                <span class="c">#or more precice but slower:</span>
            <span class="n">Nf</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span><span class="o">=</span><span class="n">Nf</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span><span class="o">/</span><span class="n">Nft</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>
            <span class="n">nfmin</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span><span class="o">=</span><span class="n">nfmin</span><span class="p">[:,</span><span class="n">ri</span><span class="p">]</span><span class="o">/</span><span class="n">Nft</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>

        <span class="c">#now we histogram over each variable</span>
        <span class="c">#for each variable parameter we define, we need to histogram separately. </span>
        <span class="k">for</span> <span class="n">vari</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">Histbins</span><span class="p">))):</span>
            <span class="c"># Now bin whilst keeping track of which contribution ends up in which bin:</span>
            <span class="c">#set bin edge locations</span>
            <span class="k">if</span> <span class="n">Histscale</span><span class="p">[</span><span class="n">vari</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;lin&#39;</span><span class="p">:</span>
                <span class="n">Hx</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">vari</span><span class="p">],</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">vari</span><span class="p">],</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c">#Hx contains the Histbins+1 bin edges, or class limits.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Hx</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">linspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">vari</span><span class="p">]),</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">vari</span><span class="p">]),</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">Hy</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">],</span><span class="n">Nreps</span><span class="p">])</span> <span class="c">#total volume fraction contribution in a bin</span>
            <span class="n">Hny</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">],</span><span class="n">Nreps</span><span class="p">])</span> <span class="c">#total number fraction contribution in a bin</span>
            <span class="n">vfminbin</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">],</span><span class="n">Nreps</span><span class="p">])</span> <span class="c">#minimum required number of contributions /in a bin/ to make a measurable impact</span>
            <span class="n">nfminbin</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">],</span><span class="n">Nreps</span><span class="p">])</span> <span class="c">#minimum required number of contributions /in a bin/ to make a measurable impact</span>
            <span class="n">Hmid</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">])</span>
            <span class="n">vfminbins</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">])</span>
            <span class="n">nfminbins</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nreps</span><span class="p">):</span>
                
                <span class="n">Rset</span> <span class="o">=</span> <span class="n">Rrep</span><span class="p">[:,</span><span class="n">vari</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="c">#the single set of R for this calculation</span>

                <span class="k">for</span> <span class="n">bini</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">]):</span>
                    <span class="n">findi</span> <span class="o">=</span> <span class="p">((</span><span class="n">Rset</span><span class="o">&gt;=</span><span class="n">Hx</span><span class="p">[</span><span class="n">bini</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">Rset</span><span class="o">&lt;</span><span class="n">Hx</span><span class="p">[</span><span class="n">bini</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span> <span class="c">#indexing which contributions fall into the radius bin</span>
                    <span class="c">#print &#39;findi: {} Vf: {}&#39;.format(shape(findi),shape(Vf))</span>
                    <span class="c">#findi = findi[:,0]</span>
                    <span class="n">Hy</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Vf</span><span class="p">[</span><span class="n">findi</span><span class="p">,</span><span class="n">ri</span><span class="p">])</span> <span class="c">#y contains the volume fraction for that radius bin</span>
                    <span class="n">Hny</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Nf</span><span class="p">[</span><span class="n">findi</span><span class="p">,</span><span class="n">ri</span><span class="p">])</span> <span class="c">#y contains the volume fraction for that radius bin</span>
                    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">findi</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">vfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">nfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vfmin</span><span class="p">[</span><span class="n">findi</span><span class="p">,</span><span class="n">ri</span><span class="p">])</span>
                        <span class="n">vfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">vfmin</span><span class="p">[</span><span class="n">findi</span><span class="p">,</span><span class="n">ri</span><span class="p">])</span>
                        <span class="n">nfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nfmin</span><span class="p">[</span><span class="n">findi</span><span class="p">,</span><span class="n">ri</span><span class="p">])</span>
                        <span class="n">nfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nfmin</span><span class="p">[</span><span class="n">findi</span><span class="p">,</span><span class="n">ri</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">isnan</span><span class="p">(</span><span class="n">Hy</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]):</span>
                        <span class="n">Hy</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                        <span class="n">Hny</span><span class="p">[</span><span class="n">bini</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">for</span> <span class="n">bini</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Histbins</span><span class="p">[</span><span class="n">vari</span><span class="p">]):</span>
                <span class="n">Hmid</span><span class="p">[</span><span class="n">bini</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hx</span><span class="p">[</span><span class="n">bini</span><span class="p">:</span><span class="n">bini</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">vb</span> <span class="o">=</span> <span class="n">vfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,:]</span>
                <span class="n">vfminbins</span><span class="p">[</span><span class="n">bini</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">vb</span><span class="p">[</span><span class="n">vb</span><span class="o">&lt;</span><span class="n">inf</span><span class="p">])</span>
                <span class="n">nb</span> <span class="o">=</span> <span class="n">nfminbin</span><span class="p">[</span><span class="n">bini</span><span class="p">,:]</span>
                <span class="n">nfminbins</span><span class="p">[</span><span class="n">bini</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nb</span><span class="p">[</span><span class="n">vb</span><span class="o">&lt;</span><span class="n">inf</span><span class="p">])</span>
            <span class="n">Hmean</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hy</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Hnmean</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hny</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Hstd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Hy</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Hnstd</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Hny</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setresult</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
                <span class="s">&#39;VariableNumber&#39;</span><span class="p">:</span><span class="n">vari</span><span class="p">,</span> <span class="c">#this line will place the results in the dict at self.results[vari]</span>
                <span class="s">&#39;Hx&#39;</span><span class="p">:</span><span class="n">Hx</span><span class="p">,</span>
                <span class="s">&#39;Hmid&#39;</span><span class="p">:</span><span class="n">Hmid</span><span class="p">,</span>
                <span class="s">&#39;Hwidth&#39;</span><span class="p">:</span><span class="n">diff</span><span class="p">(</span><span class="n">Hx</span><span class="p">),</span>
                <span class="s">&#39;Hy&#39;</span><span class="p">:</span><span class="n">Hy</span><span class="p">,</span>
                <span class="s">&#39;Hny&#39;</span><span class="p">:</span><span class="n">Hny</span><span class="p">,</span>
                <span class="s">&#39;Hmean&#39;</span><span class="p">:</span><span class="n">Hmean</span><span class="p">,</span>
                <span class="s">&#39;Hstd&#39;</span><span class="p">:</span><span class="n">Hstd</span><span class="p">,</span>
                <span class="s">&#39;Hnmean&#39;</span><span class="p">:</span><span class="n">Hnmean</span><span class="p">,</span>
                <span class="s">&#39;Hnstd&#39;</span><span class="p">:</span><span class="n">Hnstd</span><span class="p">,</span>
                <span class="s">&#39;vfminbins&#39;</span><span class="p">:</span><span class="n">vfminbins</span><span class="p">,</span>
                <span class="s">&#39;vfmin&#39;</span><span class="p">:</span><span class="n">vfmin</span><span class="p">,</span>
                <span class="s">&#39;Vf&#39;</span><span class="p">:</span><span class="n">Vf</span><span class="p">,</span>
                <span class="s">&#39;Vft&#39;</span><span class="p">:</span><span class="n">Vft</span><span class="p">,</span>
                <span class="s">&#39;nfminbins&#39;</span><span class="p">:</span><span class="n">vfminbins</span><span class="p">,</span>
                <span class="s">&#39;nfmin&#39;</span><span class="p">:</span><span class="n">vfmin</span><span class="p">,</span>
                <span class="s">&#39;Nf&#39;</span><span class="p">:</span><span class="n">Vf</span><span class="p">,</span>
                <span class="s">&#39;Nft&#39;</span><span class="p">:</span><span class="n">Vft</span><span class="p">,</span>
                <span class="s">&#39;Screps&#39;</span><span class="p">:</span><span class="n">Screps</span><span class="p">})</span>

    <span class="c">######################################## end ###############################################</span>
</div>
<div class="viewcode-block" id="McSAS.CSVwrite"><a class="viewcode-back" href="../code.html#McSAS.McSAS.CSVwrite">[docs]</a>    <span class="k">def</span> <span class="nf">CSVwrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function writes a semicolon-separated csv file to [filename] containing an arbitrary number of output variables *args. in case of variable length columns, empty fields will contain &#39;&#39;.</span>

<span class="sd">        Input arguments should be names of fields in &quot;self.results&quot;. For example:</span>
<span class="sd">        A.McCSV(&#39;hist.csv&#39;,&#39;Hx&#39;,&#39;Hwidth&#39;,&#39;Hmean&#39;,&#39;Hstd&#39;)</span>

<span class="sd">        i.e. just stick on as many columns as you&#39;d like. They will be flattened by default. a header with the names will be added.</span>
<span class="sd">        </span>
<span class="sd">        existing files with the same filename will be overwritten by default. </span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#uses sprintf rather than csv for flexibility</span>
        <span class="n">ncol</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="c">#make format string used for every line, don&#39;t need this</span>
        <span class="c">#linestr=&#39;&#39;</span>
        <span class="c">#for coli in range(ncol):</span>
        <span class="c">#    linestr=linestr+&#39;{&#39;+&#39;};&#39;</span>
        <span class="c">#linestr=linestr[0:-1]+&#39;\n&#39; #strip the last semicolon, add a newline</span>

        <span class="n">inlist</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">argi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
            <span class="n">inlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">argi</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="c">#find out the longest row</span>
        <span class="n">nrow</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">argi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
            <span class="n">nrow</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">nrow</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">inlist</span><span class="p">[</span><span class="n">argi</span><span class="p">])))</span>

        <span class="c">#now we can open the file:</span>
        <span class="n">fh</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="n">emptyfields</span><span class="o">=</span><span class="mi">0</span>
        <span class="c">#write header:</span>
        <span class="n">linestr</span><span class="o">=</span><span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">coli</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">):</span>
            <span class="n">linestr</span><span class="o">=</span><span class="n">linestr</span><span class="o">+</span><span class="s">&#39;{};&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">coli</span><span class="p">])</span>
        <span class="n">linestr</span><span class="o">=</span><span class="n">linestr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>    
        <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">linestr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rowi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrow</span><span class="p">):</span>
            <span class="n">linestr</span><span class="o">=</span><span class="s">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">coli</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncol</span><span class="p">):</span>
                <span class="c">#print &#39;rowi {} coli {} len(args[coli]) {}&#39;.format(rowi,coli,len(args[coli]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inlist</span><span class="p">[</span><span class="n">coli</span><span class="p">])</span><span class="o">&lt;=</span><span class="n">rowi</span><span class="p">:</span> <span class="c">#we ran out of numbers for this arg</span>
                    <span class="n">linestr</span><span class="o">=</span><span class="n">linestr</span><span class="o">+</span><span class="s">&#39;;&#39;</span> <span class="c">#add empty field</span>
                    <span class="n">emptyfields</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">linestr</span><span class="o">=</span><span class="n">linestr</span><span class="o">+</span><span class="s">&#39;{};&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inlist</span><span class="p">[</span><span class="n">coli</span><span class="p">][</span><span class="n">rowi</span><span class="p">])</span>
            <span class="n">linestr</span><span class="o">=</span><span class="n">linestr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>

            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">linestr</span><span class="p">)</span>

        <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">print</span> <span class="s">&#39;{} lines written with {} columns per line, and {} empty fields&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rowi</span><span class="p">,</span><span class="n">ncol</span><span class="p">,</span><span class="n">emptyfields</span><span class="p">)</span>

    <span class="c">###########################################################################################</span>
    <span class="c">################################### Monte-carlo procedure #################################</span>
    <span class="c">###########################################################################################</span></div>
<div class="viewcode-block" id="McSAS.MCFit"><a class="viewcode-back" href="../code.html#McSAS.McSAS.MCFit">[docs]</a>    <span class="k">def</span> <span class="nf">MCFit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">OutputI</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">OutputDetails</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">OutputIterations</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Object-oriented and hopefully shape-flexible form of the MC procedure.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#load dataset</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span>
        <span class="n">I</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">)</span>
        <span class="n">E</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;IERR&#39;</span><span class="p">)</span>
        <span class="c">#load parameters</span>
        <span class="n">Ncontrib</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Ncontrib&#39;</span><span class="p">)</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span>
        <span class="n">Convcrit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Convcrit&#39;</span><span class="p">)</span>
        <span class="n">Rpfactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Rpfactor&#39;</span><span class="p">)</span>
        <span class="n">Maxiter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Maxiter&#39;</span><span class="p">)</span>
        <span class="n">MaskNegI</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;MaskNegI&#39;</span><span class="p">)</span>
        <span class="n">StartFromMin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;StartFromMin&#39;</span><span class="p">)</span>
        <span class="n">Memsave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Memsave&#39;</span><span class="p">)</span>
        <span class="n">Prior</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Prior&#39;</span><span class="p">)</span>


        <span class="c">#find out how many values a shape is defined by:</span>
        <span class="n">Randfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;RAND&#39;</span><span class="p">]</span>
        <span class="n">FFfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;FF&#39;</span><span class="p">]</span>
        <span class="n">VOLfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;VOL&#39;</span><span class="p">]</span>
        <span class="n">SMEARfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;SMEAR&#39;</span><span class="p">]</span>
        <span class="n">testR</span><span class="o">=</span><span class="n">Randfunc</span><span class="p">()</span>
        <span class="n">NRval</span><span class="o">=</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">testR</span><span class="p">))</span>

        <span class="n">Rset</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ncontrib</span><span class="p">,</span><span class="n">NRval</span><span class="p">))</span>


        <span class="c"># Intialise variables</span>
        <span class="n">FFset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Vset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Niter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Conval</span> <span class="o">=</span> <span class="n">inf</span>
        <span class="n">Details</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">Ri</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#index of sphere to change. We&#39;ll sequentially change spheres, which is perfectly random since they are in random order.</span>
        
        <span class="c">#generate initial set of spheres</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">StartFromMin</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">Rvi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NRval</span><span class="p">):</span> <span class="c">#minimum bound for each value</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="n">Rvi</span><span class="p">:</span><span class="n">Rvi</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                        <span class="n">mb</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mb</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="n">Rvi</span><span class="p">:</span><span class="n">Rvi</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
                    <span class="n">Rset</span><span class="p">[:,</span><span class="n">Rvi</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Ncontrib</span><span class="p">)[:]</span><span class="o">*</span><span class="n">mb</span><span class="o">/</span><span class="mf">2.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Rset</span><span class="o">=</span><span class="n">Randfunc</span><span class="p">(</span><span class="n">Ncontrib</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Ncontrib</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">Ncontrib</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">Rset</span><span class="o">=</span><span class="n">Prior</span>
        <span class="k">elif</span> <span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="n">Ncontrib</span><span class="p">:</span>
            <span class="n">Rset</span><span class="o">=</span><span class="n">Prior</span>
        <span class="k">elif</span> <span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">&lt;</span><span class="n">Ncontrib</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;size of prior is smaller than Ncontrib. duplicating random prior values&quot;</span>
            <span class="c">#while size(Prior)&lt;Nsph:</span>
            <span class="n">Addi</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">size</span><span class="o">=</span><span class="n">Ncontrib</span><span class="o">-</span><span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">Rset</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Prior</span><span class="p">,</span><span class="n">Prior</span><span class="p">[</span><span class="n">Addi</span><span class="p">,:]))</span>
            <span class="k">print</span> <span class="s">&quot;size now:&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">Rset</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="n">Ncontrib</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Size of prior is larger than Ncontrib. removing random prior values&quot;</span>
            <span class="n">Remi</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Prior</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">size</span><span class="o">=</span><span class="n">Ncontrib</span><span class="p">)</span> <span class="c">#remaining choices</span>
            <span class="n">Rset</span><span class="o">=</span><span class="n">Prior</span><span class="p">[</span><span class="n">Remi</span><span class="p">,:]</span>
            <span class="k">print</span> <span class="s">&quot;size now:&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">Memsave</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="c">#calculate their form factors</span>
            <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">)</span>
            <span class="n">Vset</span><span class="o">=</span><span class="n">VOLfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="p">)</span>
            <span class="c">#Vset=(4.0/3*pi)*Rset**(3*Rpfactor)</span>
            <span class="c">#calculate the intensities</span>
            <span class="n">Iset</span><span class="o">=</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
            <span class="n">Vst</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c"># total volume squared</span>
            <span class="n">It</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c"># the total intensity - eq. (1)</span>
            <span class="n">It</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">It</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">It</span><span class="p">))))</span> <span class="c"># reshaped to match I and q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#calculate intensity in memory saving mode:</span>
            <span class="c">#calculate volume for entire set, this does not take much space   </span>
            <span class="n">Vset</span><span class="o">=</span><span class="n">VOLfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="p">)</span>

            <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="mi">0</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:])</span>
            <span class="n">It</span><span class="o">=</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Ncontrib</span><span class="p">):</span>
                <span class="c">#calculate their form factors</span>
                <span class="n">FFset</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="n">ri</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:])</span>
                <span class="n">It</span><span class="o">=</span><span class="n">It</span><span class="o">+</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
            <span class="n">Vst</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c"># total volume squared</span>
            <span class="n">It</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">It</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">It</span><span class="p">))))</span> <span class="c"># reshaped to match I and q</span>

        <span class="c"># Optimize the intensities and calculate convergence criterium</span>
        <span class="c">#SMEAR function goes here</span>
        <span class="n">It</span><span class="o">=</span><span class="n">SMEARfunc</span><span class="p">(</span><span class="n">It</span><span class="p">)</span>
        <span class="n">Sci</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">It</span><span class="p">)</span> <span class="c">#initial guess for the scaling factor.</span>
        <span class="n">Bgi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
        <span class="n">Sc</span><span class="p">,</span><span class="n">Conval1</span><span class="o">=</span><span class="n">Iopt_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">It</span><span class="o">/</span><span class="n">Vst</span><span class="p">,</span><span class="n">E</span><span class="p">,[</span><span class="n">Sci</span><span class="p">,</span><span class="n">Bgi</span><span class="p">])</span> <span class="c"># V1 is more robust w.r.t. a poor initial guess</span>
        <span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">It</span><span class="o">/</span><span class="n">Vst</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">)</span> <span class="c"># reoptimize with V2, there might be a slight discrepancy in the residual definitions of V1 and V2 which would prevent optimization.</span>
        <span class="c">#print &quot;Initial conval V1&quot;,Conval1</span>
        <span class="k">print</span> <span class="s">&quot;Initial Chi-squared value&quot;</span><span class="p">,</span><span class="n">Conval</span>

        <span class="k">if</span> <span class="n">OutputIterations</span><span class="p">:</span>
            <span class="c"># Output each iteration, starting with number 0. Iterations will be stored </span>
            <span class="c"># in Details[&#39;Itersph&#39;], Details[&#39;IterIfit&#39;], Details[&#39;IterConval&#39;], </span>
            <span class="c"># Details[&#39;IterSc&#39;] and Details[&#39;IterPriorUnaccepted&#39;] listing the </span>
            <span class="c"># unaccepted number of moves before the recorded accepted move.</span>
            <span class="n">Details</span><span class="p">[</span><span class="s">&#39;Itersph&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Rset</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span> <span class="c">#new iterations will (have to) be appended to this, cannot be zero-padded due to size constraints</span>
            <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterIfit&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">It</span><span class="o">/</span><span class="n">Vst</span><span class="o">*</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">])[:,</span><span class="n">newaxis</span><span class="p">]</span> <span class="c">#ibid.</span>
            <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterConVal&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Conval</span><span class="p">[</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterSc&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Sc</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterPriorUnaccepted&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c">#start the MC procedure</span>
        <span class="n">Now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">Nmoves</span><span class="o">=</span><span class="mi">0</span> <span class="c">#tracking the number of moves</span>
        <span class="n">Nnotaccepted</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">Conval</span><span class="o">&gt;</span><span class="n">Convcrit</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">Niter</span><span class="o">&lt;</span><span class="n">Maxiter</span><span class="p">):</span>
            <span class="n">Rt</span><span class="o">=</span><span class="n">Randfunc</span><span class="p">()</span>
            <span class="n">Ft</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rt</span><span class="p">)</span>
            <span class="n">Vtt</span><span class="o">=</span><span class="n">VOLfunc</span><span class="p">(</span><span class="n">Rt</span><span class="p">,</span><span class="n">Rpfactor</span><span class="p">)</span>
            <span class="n">Itt</span><span class="o">=</span><span class="p">(</span><span class="n">Ft</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Vtt</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c"># Calculate new total intensity</span>
            <span class="k">if</span> <span class="n">Memsave</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
                <span class="n">Itest</span><span class="o">=</span><span class="p">(</span><span class="n">It</span><span class="o">-</span><span class="n">Iset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">+</span><span class="n">Itt</span><span class="p">)</span> <span class="c"># we do subtractions and additions, which give us another factor 2 improvement in speed over summation and is much more scalable</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Fo</span><span class="o">=</span><span class="n">FFfunc</span><span class="p">(</span><span class="n">Rset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:][</span><span class="n">newaxis</span><span class="p">,:])</span>
                <span class="n">Io</span><span class="o">=</span><span class="p">(</span><span class="n">Fo</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Vset</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">Itest</span><span class="o">=</span><span class="p">(</span><span class="n">It</span><span class="o">-</span><span class="n">Io</span><span class="o">+</span><span class="n">Itt</span><span class="p">)</span>

            <span class="c">#SMEAR function goes here</span>
            <span class="n">Itest</span><span class="o">=</span><span class="n">SMEARfunc</span><span class="p">(</span><span class="n">Itest</span><span class="p">)</span>
            <span class="n">Vstest</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Vst</span><span class="p">)</span><span class="o">-</span><span class="n">Vset</span><span class="p">[</span><span class="n">Ri</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Vtt</span><span class="o">**</span><span class="mi">2</span>
            <span class="c"># optimize intensity and calculate convergence criterium</span>
            <span class="n">Sct</span><span class="p">,</span><span class="n">Convalt</span> <span class="o">=</span> <span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Itest</span><span class="o">/</span><span class="n">Vstest</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">)</span> <span class="c"># using version two here for a &gt;10 times speed improvement</span>
            <span class="c"># test if the radius change is an improvement:</span>
            <span class="k">if</span> <span class="n">Convalt</span><span class="o">&lt;</span><span class="n">Conval</span><span class="p">:</span> <span class="c"># it&#39;s better</span>
                <span class="k">if</span> <span class="n">Memsave</span><span class="p">:</span>
                    <span class="n">Rset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:],</span><span class="n">It</span><span class="p">,</span><span class="n">Vset</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Vst</span><span class="p">,</span><span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="p">(</span><span class="n">Rt</span><span class="p">,</span><span class="n">Itest</span><span class="p">,</span><span class="n">Vtt</span><span class="p">,</span><span class="n">Vstest</span><span class="p">,</span><span class="n">Sct</span><span class="p">,</span><span class="n">Convalt</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Rset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:],</span><span class="n">Iset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:],</span><span class="n">It</span><span class="p">,</span><span class="n">Vset</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Vst</span><span class="p">,</span><span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="p">(</span><span class="n">Rt</span><span class="p">,</span><span class="n">Itt</span><span class="p">,</span><span class="n">Itest</span><span class="p">,</span><span class="n">Vtt</span><span class="p">,</span><span class="n">Vstest</span><span class="p">,</span><span class="n">Sct</span><span class="p">,</span><span class="n">Convalt</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&quot;Improvement in iteration number </span><span class="si">%i</span><span class="s">, Chi-squared value </span><span class="si">%f</span><span class="s"> of </span><span class="si">%f</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Niter</span><span class="p">,</span><span class="n">Conval</span><span class="p">,</span><span class="n">Convcrit</span><span class="p">),</span>
                <span class="n">Nmoves</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">OutputIterations</span><span class="p">:</span>
                    <span class="c"># output each iteration, starting with number 0. </span>
                    <span class="c"># Iterations will be stored in Details[&#39;Itersph&#39;], Details[&#39;IterIfit&#39;], </span>
                    <span class="c"># Details[&#39;IterConval&#39;], Details[&#39;IterSc&#39;] and </span>
                    <span class="c"># Details[&#39;IterPriorUnaccepted&#39;] listing the unaccepted </span>
                    <span class="c"># number of moves before the recorded accepted move.</span>
                    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;Itersph&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Details</span><span class="p">[</span><span class="s">&#39;Itersph&#39;</span><span class="p">],</span><span class="n">Rset</span><span class="p">[:,:,</span><span class="n">newaxis</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c">#new iterations will (have to) be appended to this, cannot be zero-padded due to size constraints</span>
                    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterIfit&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterIfit&#39;</span><span class="p">],(</span><span class="n">Itest</span><span class="o">/</span><span class="n">Vstest</span><span class="o">*</span><span class="n">Sct</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Sct</span><span class="p">[</span><span class="mi">1</span><span class="p">])[:,</span><span class="n">newaxis</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c">#ibid.</span>
                    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterConVal&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterConVal&#39;</span><span class="p">],</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Convalt</span><span class="p">)[</span><span class="n">newaxis</span><span class="p">]))</span>
                    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterSc&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterSc&#39;</span><span class="p">],</span><span class="n">Sct</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterPriorUnaccepted&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Details</span><span class="p">[</span><span class="s">&#39;IterPriorUnaccepted&#39;</span><span class="p">],</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Nnotaccepted</span><span class="p">)[</span><span class="n">newaxis</span><span class="p">]))</span>
                <span class="n">Nnotaccepted</span><span class="o">=-</span><span class="mi">1</span>
            <span class="c"># else nothing to do</span>
            <span class="n">Ri</span><span class="o">+=</span><span class="mi">1</span> <span class="c"># move to next sphere in list</span>
            <span class="n">Ri</span><span class="o">=</span><span class="n">Ri</span><span class="o">%</span><span class="p">(</span><span class="n">Ncontrib</span><span class="p">)</span> <span class="c"># loop if last sphere</span>
            <span class="n">Nnotaccepted</span><span class="o">+=</span><span class="mi">1</span> <span class="c"># number of non-accepted moves, resets to zero after accepted move.</span>
            <span class="n">Niter</span><span class="o">+=</span><span class="mi">1</span> <span class="c"># add one to the iteration number           </span>
        <span class="k">if</span> <span class="n">Niter</span><span class="o">&gt;=</span><span class="n">Maxiter</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;exited due to max. number of iterations (</span><span class="si">%i</span><span class="s">) reached&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Niter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;Normal exit&quot;</span>
        <span class="k">print</span> <span class="s">&quot;Number of iterations per second&quot;</span><span class="p">,</span><span class="n">Niter</span><span class="o">/</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">Now</span><span class="o">+</span><span class="mf">0.001</span><span class="p">)</span> <span class="c">#the +0.001 seems necessary to prevent a divide by zero error on some Windows systems.   </span>
        <span class="k">print</span> <span class="s">&quot;Number of valid moves&quot;</span><span class="p">,</span><span class="n">Nmoves</span>
        <span class="k">print</span> <span class="s">&quot;final Chi-squared value </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Conval</span><span class="p">)</span>
        <span class="n">Details</span><span class="p">[</span><span class="s">&#39;Niter&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Niter</span>
        <span class="n">Details</span><span class="p">[</span><span class="s">&#39;Nmoves&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Nmoves</span>
        <span class="n">Details</span><span class="p">[</span><span class="s">&#39;elapsed&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">Now</span><span class="o">+</span><span class="mf">0.001</span><span class="p">)</span>

        <span class="c">#Ifinal=sum(Iset,0)/sum(Vset**2)</span>
        <span class="n">Ifinal</span><span class="o">=</span><span class="n">It</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Ifinal</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ifinal</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">Ifinal</span><span class="p">))))</span>
        <span class="c">#SMEAR function goes here</span>
        <span class="n">Ifinal</span><span class="o">=</span><span class="n">SMEARfunc</span><span class="p">(</span><span class="n">Ifinal</span><span class="p">)</span>
        <span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Ifinal</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">)</span>    
        <span class="k">if</span> <span class="n">OutputI</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">OutputDetails</span><span class="p">:</span>
                <span class="c">#DEBUG:</span>
                <span class="c">#print &#39;Rset: {}, I: {}, Conval: {}&#39;.format(shape(Rset),shape((Ifinal*Sc[0]+Sc[1])),shape(Conval))</span>

                <span class="k">return</span> <span class="n">Rset</span><span class="p">,(</span><span class="n">Ifinal</span><span class="o">*</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Conval</span><span class="p">,</span><span class="n">Details</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Rset</span><span class="p">,(</span><span class="n">Ifinal</span><span class="o">*</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Conval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">OutputDetails</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Rset</span><span class="p">,</span><span class="n">Conval</span><span class="p">,</span><span class="n">Details</span> <span class="c"># ifinal cannot be output with variable length intensity outputs (in case of masked negative intensities or q limits)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Rset</span><span class="p">,</span><span class="n">Conval</span> <span class="c"># ifinal cannot be output with variable length intensity outputs (in case of masked negative intensities or q limits)</span>

    <span class="c">######################################## end ###############################################</span>
</div>
    <span class="k">def</span> <span class="nf">_Iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">I0</span><span class="p">,</span><span class="n">I1</span><span class="p">,</span><span class="n">startval</span><span class="p">):</span>
        <span class="c">#intensity optimization function, returning values and reduced chi squared.</span>
        <span class="k">pass</span>

        
<div class="viewcode-block" id="McSAS.set_defaults"><a class="viewcode-back" href="../code.html#McSAS.McSAS.set_defaults">[docs]</a>    <span class="k">def</span> <span class="nf">set_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populates the default parameter settings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c">#fieldnames</span>
        <span class="c">#fnames=list([&#39;Bounds&#39;,&#39;Ncontrib&#39;,&#39;Maxiter&#39;,&#39;Rpfactor&#39;,&#39;Nreps&#39;,&#39;qlims&#39;,&#39;psilims&#39;,&#39;Histbins&#39;,&#39;Histscale&#39;,&#39;drhosqr&#39;,&#39;Convcrit&#39;,&#39;StartFromMin&#39;,&#39;Maxntry&#39;])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">=</span><span class="p">{</span>
                <span class="s">&#39;Bounds&#39;</span><span class="p">:[],</span>
                <span class="s">&#39;Ncontrib&#39;</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span>
                <span class="s">&#39;Maxiter&#39;</span><span class="p">:</span><span class="mf">1e5</span><span class="p">,</span>
                <span class="s">&#39;Rpfactor&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="s">&#39;Nreps&#39;</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span>
                <span class="s">&#39;qlims&#39;</span><span class="p">:[],</span>
                <span class="s">&#39;psilims&#39;</span><span class="p">:[],</span>
                <span class="s">&#39;Priors&#39;</span><span class="p">:[],</span> <span class="c">#of shape Rrep, to be used as initial guess for Analyse function, Analyse will pass on a Prior to MCFit.</span>
                <span class="s">&#39;Prior&#39;</span><span class="p">:[],</span> <span class="c">#of shape Rset, to be used as initial guess for MCFit function</span>
                <span class="s">&#39;Histbins&#39;</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span>
                <span class="s">&#39;Histscale&#39;</span><span class="p">:</span><span class="s">&#39;log&#39;</span><span class="p">,</span>
                <span class="s">&#39;Histweight&#39;</span><span class="p">:</span><span class="s">&#39;volume&#39;</span><span class="p">,</span> <span class="c">#can be set to &quot;volume&quot; or &quot;number&quot;</span>
                <span class="s">&#39;drhosqr&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                <span class="s">&#39;Convcrit&#39;</span><span class="p">:</span><span class="mf">1.</span><span class="p">,</span>
                <span class="s">&#39;StartFromMin&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">,</span>
                <span class="s">&#39;Maxntry&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                <span class="s">&#39;MaskNegI&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">,</span>
                <span class="s">&#39;Memsave&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">,</span>
                <span class="s">&#39;Plot&#39;</span><span class="p">:</span><span class="bp">False</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="o">=</span><span class="p">{</span>
                <span class="s">&#39;BOUNDS&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">SphBounds</span><span class="p">,</span> <span class="c">#this function has to give a vector the size of the number of variables *2 (lower and upper)</span>
                <span class="s">&#39;RAND&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">random_uniform_sph</span><span class="p">,</span>
                <span class="s">&#39;FF&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">FF_sph_1D</span><span class="p">,</span> <span class="c">#1D spheres</span>
                <span class="s">&#39;VOL&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">vol_sph</span><span class="p">,</span>
                <span class="s">&#39;SMEAR&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_passthrough</span><span class="p">}</span> <span class="c">#none</span>
</div>
<div class="viewcode-block" id="McSAS.random_uniform_ell"><a class="viewcode-back" href="../code.html#McSAS.McSAS.random_uniform_ell">[docs]</a>    <span class="k">def</span> <span class="nf">random_uniform_ell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Nell</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c">#get parameters from self</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span> 
        <span class="c">#generate Nsph random numbers</span>
        <span class="n">Rset</span><span class="o">=</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nell</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">Rset</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Nell</span><span class="p">)</span>
        <span class="n">Rset</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span><span class="n">Nell</span><span class="p">)</span>
        <span class="n">Rset</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span><span class="n">Nell</span><span class="p">)</span>

        <span class="c">#output Nsph-by-3 array</span>
        <span class="k">return</span> <span class="n">Rset</span>
</div>
<div class="viewcode-block" id="McSAS.random_logR_ell"><a class="viewcode-back" href="../code.html#McSAS.McSAS.random_logR_ell">[docs]</a>    <span class="k">def</span> <span class="nf">random_logR_ell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Nell</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="s">&quot;like uniform, but with a higher likelihood of sampling smaller sizes. May speed up some fitting procedures.&quot;</span>
        <span class="c">#get parameters from self</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span> 
        <span class="c">#generate Nsph random numbers</span>
        <span class="n">Rset</span><span class="o">=</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nell</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">Rset</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="n">Nell</span><span class="p">))</span>
        <span class="n">Rset</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span><span class="n">log10</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">])),</span><span class="n">Nell</span><span class="p">))</span>
        <span class="n">Rset</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span><span class="n">Nell</span><span class="p">)</span>

        <span class="c">#output Nsph-by-3 array</span>
        <span class="k">return</span> <span class="n">Rset</span>
</div>
    <span class="k">def</span> <span class="nf">random_uniform_sph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Nsph</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c">#get parameters from self</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span> 
        <span class="c">#generate Nsph random numbers</span>

        <span class="n">Rset</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">),</span><span class="n">Nsph</span><span class="p">)</span>
        <span class="n">Rset</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">Rset</span><span class="p">,(</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">Rset</span><span class="p">)),</span><span class="mi">1</span><span class="p">))</span>

        <span class="c">#output Nsph-by-1 array</span>
        <span class="k">return</span> <span class="n">Rset</span>

<div class="viewcode-block" id="McSAS.vol_ell"><a class="viewcode-back" href="../code.html#McSAS.McSAS.vol_ell">[docs]</a>    <span class="k">def</span> <span class="nf">vol_ell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&#39;&#39;&#39;calculates the volume of an ellipsoid, taking Rpfactor from input or preset parameters&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">Rpfactor</span><span class="o">==</span><span class="p">[]:</span>
            <span class="n">Rpfactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Rpfactor&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="p">((</span><span class="mf">4.0</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">Rset</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="n">Rset</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">))[:,</span><span class="n">newaxis</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="McSAS.vol_sph"><a class="viewcode-back" href="../code.html#McSAS.McSAS.vol_sph">[docs]</a>    <span class="k">def</span> <span class="nf">vol_sph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Rset</span><span class="p">,</span><span class="n">Rpfactor</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&#39;&#39;&#39;calculates the volume of a sphere, taking Rpfactor from input or preset parameters&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">Rpfactor</span><span class="o">==</span><span class="p">[]:</span>
            <span class="n">Rpfactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Rpfactor&#39;</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">Rset</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="McSAS.FF_sph_1D"><a class="viewcode-back" href="../code.html#McSAS.McSAS.FF_sph_1D">[docs]</a>    <span class="k">def</span> <span class="nf">FF_sph_1D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Rset</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the Rayleigh function for a sphere</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">Rset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span> <span class="c"># multimensional matrices required, input Rsph has to be Nsph-by-1. q has to be 1-by-N</span>
            <span class="n">qR</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">Rset</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Rset</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qR</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Rset</span><span class="p">)</span>

        <span class="n">Fsph</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">qR</span><span class="p">)</span><span class="o">-</span><span class="n">qR</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">qR</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">qR</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Fsph</span>
</div>
<div class="viewcode-block" id="McSAS.FF_ell_2D"><a class="viewcode-back" href="../code.html#McSAS.McSAS.FF_ell_2D">[docs]</a>    <span class="k">def</span> <span class="nf">FF_ell_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">Rset</span><span class="o">=</span><span class="p">[],</span><span class="n">Q</span><span class="o">=</span><span class="p">[],</span><span class="n">PSI</span><span class="o">=</span><span class="p">[]):</span>
        <span class="s">&quot;all 2D functions should be able to potentially take externally supplied Q and PSI vectors&quot;</span>
        <span class="c">#Rset is n-by-3. R1=Rset[:,0],R2=Rset[:,1],R3=Rset[:,2]</span>
        <span class="c">#R1&lt;R2, prolate ellipsoid (cigar-shaped), R1&gt;R2, oblate ellipsoid (disk-shaped), rotation is offset from perfect orientation (psi-rot)</span>
        <span class="n">d_to_r</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">360</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="c">#degrees to radians, forget the dot and get yourself into a non-floating point mess, even though pi is floating point...</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">==</span><span class="p">[]:</span>
            <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span><span class="c">#1-by-N</span>
            <span class="n">psi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;PSI&#39;</span><span class="p">)</span><span class="c">#1-by-N</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#externally supplied data</span>
            <span class="n">q</span><span class="o">=</span><span class="n">Q</span>
            <span class="n">psi</span><span class="o">=</span><span class="n">PSI</span>
        <span class="n">R1</span><span class="p">,</span><span class="n">R2</span><span class="p">,</span><span class="n">rot</span><span class="o">=</span><span class="n">Rset</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">Rset</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span><span class="n">Rset</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">NR</span><span class="o">=</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">R1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">NR</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c">#option 1:</span>
            <span class="n">sda</span><span class="o">=</span><span class="n">sin</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">)</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
            <span class="n">cda</span><span class="o">=</span><span class="n">cos</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">)</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
            <span class="n">r</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R1</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sda</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">R2</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cda</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">qr</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">r</span>
            <span class="n">Fell</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span><span class="o">-</span><span class="n">qr</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">qr</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">qr</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
            <span class="c">##quicker? no, 20% slower:</span>
            <span class="c">#Fell=3*(</span>
            <span class="c">#        sin(q*sqrt(R1**2*sin((psi-rot)*d_to_r)**2</span>
            <span class="c">#            +R2**2*cos((psi-rot)*d_to_r)**2))</span>
            <span class="c">#        -q*sqrt(R1**2*sin((psi-rot)*d_to_r)**2</span>
            <span class="c">#            +R2**2*cos((psi-rot)*d_to_r)**2)</span>
            <span class="c">#        *cos(q*sqrt(R1**2*sin((psi-rot)*d_to_r)**2</span>
            <span class="c">#            +R2**2*cos((psi-rot)*d_to_r)**2)))/((q*sqrt(R1**2*sin((psi-rot)*d_to_r)**2</span>
            <span class="c">#                +R2**2*cos((psi-rot)*d_to_r)**2))**3)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c">#calculate a series</span>
            <span class="n">Fell</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">NR</span><span class="p">,</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">q</span><span class="p">))])</span>
            <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1</span><span class="p">)):</span>
                <span class="n">sda</span><span class="o">=</span><span class="n">sin</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">[</span><span class="n">Ri</span><span class="p">])</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
                <span class="n">cda</span><span class="o">=</span><span class="n">cos</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">[</span><span class="n">Ri</span><span class="p">])</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
                <span class="n">r</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R1</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sda</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">R2</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cda</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">qr</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">r</span>
                <span class="n">Fell</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span><span class="o">-</span><span class="n">qr</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">qr</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">qr</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Fell</span> <span class="c">#this will be n-by-len(q) array</span>
</div>
    <span class="k">def</span> <span class="nf">_passthrough</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">In</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;a passthrough mechanism returning the input unchanged&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">In</span>

<div class="viewcode-block" id="McSAS.reshape_fitdata"><a class="viewcode-back" href="../code.html#McSAS.McSAS.reshape_fitdata">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_fitdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This function ensures that q, I, PSI and E are in 1-by-n shape&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="p">[</span><span class="n">key</span><span class="p">],(</span><span class="mi">1</span><span class="p">,</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="p">[</span><span class="n">key</span><span class="p">]))))</span>
</div>
<div class="viewcode-block" id="McSAS.clip_dataset"><a class="viewcode-back" href="../code.html#McSAS.McSAS.clip_dataset">[docs]</a>    <span class="k">def</span> <span class="nf">clip_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;if q and/or psi limits are supplied in self.parameters, clips the dataset to within the supplied limits. Copies data to self.fitdata if no limits are set.&#39;&#39;&#39;</span>

        <span class="n">qlims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;qlims&#39;</span><span class="p">)</span>
        <span class="n">psilims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;psilims&#39;</span><span class="p">)</span>
        <span class="n">dataset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        
        <span class="n">validbools</span><span class="o">=</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s">&#39;Q&#39;</span><span class="p">])</span>
        <span class="c"># Optional masking of negative intensity</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="s">&#39;MaskNegI&#39;</span><span class="p">]:</span>
            <span class="n">validbools</span><span class="o">=</span><span class="n">validbools</span><span class="o">*</span><span class="p">(</span><span class="n">I</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">qlims</span><span class="o">==</span><span class="p">[])</span><span class="ow">and</span><span class="p">(</span><span class="n">psilims</span><span class="o">==</span><span class="p">[]):</span>
            <span class="c">#q limits not set, simply copy dataset to fitdata</span>
            <span class="n">validbools</span><span class="o">=</span><span class="n">validbools</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="n">qlims</span><span class="o">==</span><span class="p">[])):</span> <span class="c">#and qlims is implicitly set</span>
            <span class="n">validbools</span> <span class="o">=</span> <span class="n">validbools</span><span class="o">*</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s">&#39;Q&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">qlims</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s">&#39;Q&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">qlims</span><span class="p">))</span> <span class="c">#excluding the lower q limit may prevent q=0 from appearing</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span><span class="p">(</span><span class="n">psilims</span><span class="o">==</span><span class="p">[])):</span> <span class="c">#we assume here that we have a dataset [&#39;PSI&#39;]</span>
            <span class="n">validbools</span> <span class="o">=</span> <span class="n">validbools</span><span class="o">*</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s">&#39;PSI&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psilims</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s">&#39;PSI&#39;</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psilims</span><span class="p">))</span> <span class="c">#excluding the lower q limit may prevent q=0 from appearing</span>

        <span class="c">#not so nice to do this outside of a proper function, but this is probably the only instance of setting this.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">dataset</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">validbools</span><span class="p">]</span>

        <span class="c">#self.fitdata=fitdata</span>
        </div>
<div class="viewcode-block" id="McSAS.getpar"><a class="viewcode-back" href="../code.html#McSAS.McSAS.getpar">[docs]</a>    <span class="k">def</span> <span class="nf">getpar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parname</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&#39;&#39;&#39;gets the value of a parameter, so simple it is probably superfluous&#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">parname</span><span class="o">==</span><span class="p">[]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">parname</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="McSAS.getdata"><a class="viewcode-back" href="../code.html#McSAS.McSAS.getdata">[docs]</a>    <span class="k">def</span> <span class="nf">getdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parname</span><span class="o">=</span><span class="p">[],</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;fit&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;gets the values of a dataset, retrieves from fitdata (clipped) by default. If the original data is wanted, use &quot;dataset=&#39;original&quot; as kwarg. &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parname</span><span class="o">==</span><span class="p">[]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dataset</span><span class="o">==</span><span class="s">&#39;fit&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parname</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="ow">and</span><span class="p">(</span><span class="n">dataset</span><span class="o">==</span><span class="s">&#39;fit&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitdata</span><span class="p">[</span><span class="n">parname</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">parname</span><span class="p">]</span>
</div>
    <span class="k">def</span> <span class="nf">getresult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">parname</span><span class="o">=</span><span class="p">[],</span><span class="n">VariableNumber</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parname</span><span class="o">==</span><span class="p">[]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="n">VariableNumber</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="n">VariableNumber</span><span class="p">][</span><span class="n">parname</span><span class="p">]</span>

<div class="viewcode-block" id="McSAS.setresult"><a class="viewcode-back" href="../code.html#McSAS.McSAS.setresult">[docs]</a>    <span class="k">def</span> <span class="nf">setresult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the supplied keyword-value pairs to the result. These can be arbitrary. Varnum is the sequence number of the variable for which data is stored. Default is set to 0, which is where the output of the MC routine is put before histogramming. The Histogramming procedure may populate more variables if so needed.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="s">&#39;VariableNumber&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">varnum</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;VariableNumber&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">varnum</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span><span class="o">&lt;</span><span class="p">(</span><span class="n">varnum</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="c">#make sure there is a dictionary in the location we want to save the result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">())</span>
        
        <span class="n">rdict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">[</span><span class="n">varnum</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">rdict</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="McSAS.setpar"><a class="viewcode-back" href="../code.html#McSAS.McSAS.setpar">[docs]</a>    <span class="k">def</span> <span class="nf">setpar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the supplied parameters given in keyword-value pairs for known setting keywords (unknown key-value pairs are skipped)</span>
<span class="sd">        If a supplied parameter is one of the function names, it is stored in the self.functions dict.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c">#no need to store unknown keywords.</span>
</div>
<div class="viewcode-block" id="McSAS.setdata"><a class="viewcode-back" href="../code.html#McSAS.McSAS.setdata">[docs]</a>    <span class="k">def</span> <span class="nf">setdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the supplied data in the proper location.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">datasetlist</span><span class="o">=</span><span class="nb">list</span><span class="p">([</span><span class="s">&#39;Q&#39;</span><span class="p">,</span><span class="s">&#39;I&#39;</span><span class="p">,</span><span class="s">&#39;PSI&#39;</span><span class="p">,</span><span class="s">&#39;IERR&#39;</span><span class="p">])</span> <span class="c">#list of valid things</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">datasetlist</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c">#do not store non-dataset values.</span>
</div>
<div class="viewcode-block" id="McSAS.EllBounds_2D"><a class="viewcode-back" href="../code.html#McSAS.McSAS.EllBounds_2D">[docs]</a>    <span class="k">def</span> <span class="nf">EllBounds_2D</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function will take the q and psi input bounds and outputs properly formatted two-element size bounds for ellipsoids. Ellipsoids are defined by their equatorial radius, meridional radius and axis misalignment (default -45 to 45 degrees in PSI).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span>
        <span class="n">qBounds</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">pi</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="n">pi</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)),</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">)))))])</span> <span class="c"># reasonable, but not necessarily correct, parameters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Bounds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Bounds not provided, so set related to minimum q or minimum q step and maximum q. Lower and upper bounds are {0} and {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Bounds</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">45</span><span class="p">,</span><span class="mi">45</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Bounds</span><span class="p">)</span><span class="o">==</span><span class="mi">6</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c">#print &#39;Bounds provided, set to {} and {}&#39;.format(Bounds[0],Bounds[1])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Wrong number of Bounds provided, defaulting to {} and {} for radii, -45, 45 for misalignment&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Bounds</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">45</span><span class="p">,</span><span class="mi">45</span><span class="p">])</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">])])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="n">Bounds</span><span class="o">=</span><span class="n">Bounds</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="McSAS.SphBounds"><a class="viewcode-back" href="../code.html#McSAS.McSAS.SphBounds">[docs]</a>    <span class="k">def</span> <span class="nf">SphBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function will take the q and input bounds and outputs properly formatted two-element size bounds.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">)</span>
        <span class="n">qBounds</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">pi</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="n">pi</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)),</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">q</span><span class="p">)))))])</span> <span class="c"># reasonable, but not necessarily correct, parameters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Bounds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Bounds not provided, so set related to minimum q or minimum q step and maximum q. Lower and upper bounds are {0} and {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Bounds</span><span class="o">=</span><span class="n">qBounds</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Bounds</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Only one bound provided, assuming it denotes the maximum. Lower and upper bounds are set to {0} and {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Bounds</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Bounds</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Bounds</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c">#print &#39;Bounds provided, set to {} and {}&#39;.format(Bounds[0],Bounds[1])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&#39;Wrong number of Bounds provided, defaulting to {} and {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qBounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Bounds</span><span class="o">=</span><span class="n">qbounds</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">)])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="n">Bounds</span><span class="o">=</span><span class="n">Bounds</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="McSAS.check_parameters"><a class="viewcode-back" href="../code.html#McSAS.McSAS.check_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">check_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;in here we can place checks for the parameters, for example to make sure histbins is defined for all, or to check if all parameters fall within their limits&#39;&#39;&#39;</span>
        <span class="c">#for now, all I need is a check that Histbins is a 1D vector with n values, where n is the number of parameters specifying a shape. </span>

        <span class="n">testR</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="s">&#39;RAND&#39;</span><span class="p">]()</span>
        <span class="n">NRval</span><span class="o">=</span><span class="n">prod</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">testR</span><span class="p">))</span>
        <span class="n">Histbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histbins&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Histbins</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span> <span class="c">#meaning it will be a string</span>
            <span class="n">HB</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NRval</span><span class="p">):</span>
                <span class="n">HB</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">Histbins</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="n">Histbins</span><span class="o">=</span><span class="n">HB</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Histbins</span><span class="p">)</span><span class="o">&lt;</span><span class="n">NRval</span><span class="p">:</span>
            <span class="c">#histbins is a list but not of the right length</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Histscale</span><span class="p">)</span><span class="o">&lt;</span><span class="n">NRval</span><span class="p">:</span>
                <span class="n">Histbins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Histbins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="n">Histbins</span><span class="o">=</span><span class="n">Histbins</span><span class="p">)</span>
        <span class="c">#now check histscale</span>
        <span class="n">Histscale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histscale&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">Histscale</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span> <span class="c">#meaning it will be a string</span>
            <span class="n">HS</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NRval</span><span class="p">):</span>
                <span class="n">HS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Histscale</span><span class="p">)</span> <span class="c">#repeat until we have enough</span>
            <span class="c">#replace histscale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="n">Histscale</span><span class="o">=</span><span class="n">HS</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">Histscale</span><span class="p">)</span><span class="o">&lt;</span><span class="n">NRval</span><span class="p">:</span>
            <span class="c">#histscale is a list but not of the right length</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Histscale</span><span class="p">)</span><span class="o">&lt;</span><span class="n">NRval</span><span class="p">:</span>
                <span class="n">Histscale</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Histscale</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setpar</span><span class="p">(</span><span class="n">Histscale</span><span class="o">=</span><span class="n">Histscale</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="McSAS.Plot"><a class="viewcode-back" href="../code.html#McSAS.McSAS.Plot">[docs]</a>    <span class="k">def</span> <span class="nf">Plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">AxisMargin</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function plots the output of the Monte-Carlo procedure in two windows, with the left window the measured signal versus the fitted intensity (on double-log scale), and the righthand window the size distribution</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.font_manager</span> <span class="kn">as</span> <span class="nn">fm</span>
        <span class="k">def</span> <span class="nf">setaxis</span><span class="p">(</span><span class="n">ah</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">matplotlib.font_manager</span> <span class="kn">as</span> <span class="nn">fm</span>
            <span class="n">plotfont</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span>
                        <span class="c">#this only works for macs, doesn&#39;t it?</span>
                        <span class="c">#family = &#39;Courier New Bold&#39;, fname = &#39;/Library/Fonts/Courier New Bold.ttf&#39;)</span>
                        <span class="n">family</span> <span class="o">=</span> <span class="s">&#39;Arial&#39;</span><span class="p">)</span>
            <span class="n">textfont</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span> <span class="c">#Baskerville.ttc does not work when saving to eps</span>
                        <span class="c">#family = &#39;Times New Roman&#39;, fname = &#39;/Library/Fonts/Times New Roman.ttf&#39;)</span>
                        <span class="n">family</span> <span class="o">=</span> <span class="s">&#39;Times&#39;</span><span class="p">)</span>
            <span class="s">&quot;sets the axes parameters. axtyp can be one of &#39;q&#39; or &#39;R&#39;&quot;</span>
            <span class="c">#setaxis font and ticks</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">ah</span><span class="o">.</span><span class="n">get_yticks</span><span class="p">(),</span> <span class="n">fontproperties</span> <span class="o">=</span> <span class="n">plotfont</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s">&#39;large&#39;</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">ah</span><span class="o">.</span><span class="n">get_xticks</span><span class="p">(),</span> <span class="n">fontproperties</span> <span class="o">=</span> <span class="n">plotfont</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s">&#39;large&#39;</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">ah</span><span class="o">.</span><span class="n">get_xlabel</span><span class="p">(),</span> <span class="n">fontproperties</span><span class="o">=</span><span class="n">textfont</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s">&#39;x-large&#39;</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ah</span><span class="o">.</span><span class="n">get_ylabel</span><span class="p">(),</span> <span class="n">fontproperties</span><span class="o">=</span><span class="n">textfont</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s">&#39;x-large&#39;</span><span class="p">)</span>
            <span class="c">#q_ax.set_yticklabels(q_ax.get_yticks(), fontproperties = plotfont)</span>
            <span class="c">#q_ax.set_xticklabels(q_ax.get_xticks(), fontproperties = plotfont)</span>
            <span class="c">#R_ax.spines[&#39;bottom&#39;].set_color(&#39;black&#39;)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_lw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">&#39;both&#39;</span><span class="p">,</span><span class="n">colors</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="s">&#39;major&#39;</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="s">&#39;in&#39;</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">&#39;x&#39;</span><span class="p">,</span><span class="n">colors</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="s">&#39;minor&#39;</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="s">&#39;in&#39;</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">ah</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s">&#39;y&#39;</span><span class="p">,</span><span class="n">colors</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">which</span><span class="o">=</span><span class="s">&#39;minor&#39;</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="s">&#39;in&#39;</span><span class="p">,</span><span class="n">length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="c">#q_ax.spines[&#39;bottom&#39;].set_lw(2)</span>
            <span class="c">#q_ax.spines[&#39;top&#39;].set_lw(2)</span>
            <span class="c">#q_ax.spines[&#39;left&#39;].set_lw(2)</span>
            <span class="c">#q_ax.spines[&#39;right&#39;].set_lw(2)</span>
            <span class="c">#q_ax.tick_params(axis=&#39;both&#39;,colors=&#39;black&#39;,width=2,which=&#39;major&#39;,direction=&#39;in&#39;,length=6)</span>
            <span class="c">#q_ax.tick_params(axis=&#39;x&#39;,colors=&#39;black&#39;,width=2,which=&#39;minor&#39;,direction=&#39;in&#39;,length=3)</span>
            <span class="c">#q_ax.tick_params(axis=&#39;y&#39;,colors=&#39;black&#39;,width=2,which=&#39;minor&#39;,direction=&#39;in&#39;,length=3)</span>
            <span class="n">locs</span><span class="p">,</span><span class="n">labels</span> <span class="o">=</span> <span class="n">xticks</span><span class="p">()</span>
            <span class="n">xticks</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&quot;</span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">x</span><span class="p">,</span> <span class="n">locs</span><span class="p">))</span>
            <span class="n">locs</span><span class="p">,</span><span class="n">labels</span> <span class="o">=</span> <span class="n">yticks</span><span class="p">()</span>
            <span class="n">yticks</span><span class="p">(</span><span class="n">locs</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s">&quot;</span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">x</span><span class="p">,</span> <span class="n">locs</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ah</span>

        <span class="c">#load parameters</span>
        <span class="n">Histscale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histscale&#39;</span><span class="p">)</span>
        <span class="n">Histweight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histweight&#39;</span><span class="p">)</span>
        <span class="c">#load result</span>
        <span class="n">Result</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">()</span>
        <span class="c">#check how many result plots we need to generate: maximum three.</span>
        <span class="n">nhists</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">Histscale</span><span class="p">)</span>

        <span class="c">#set plot font</span>
        <span class="n">plotfont</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span>
                    <span class="n">size</span><span class="o">=</span><span class="s">&#39;large&#39;</span><span class="p">,</span>
                    <span class="n">family</span> <span class="o">=</span> <span class="s">&#39;Arial&#39;</span><span class="p">)</span>
        <span class="n">textfont</span> <span class="o">=</span> <span class="n">fm</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">(</span> <span class="c">#Baskerville.ttc does not work when saving to eps</span>
                    <span class="n">size</span><span class="o">=</span><span class="s">&#39;large&#39;</span><span class="p">,</span>
                    <span class="n">family</span> <span class="o">=</span> <span class="s">&#39;Times&#39;</span><span class="p">)</span>
        <span class="c">#initialize figure and axes</span>
        <span class="n">fig</span><span class="o">=</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="p">(</span><span class="n">nhists</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="mi">7</span><span class="p">),</span><span class="n">dpi</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span><span class="n">facecolor</span><span class="o">=</span><span class="s">&#39;w&#39;</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">)</span>
        <span class="c">#load original dataset</span>
        <span class="n">q</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;Q&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        <span class="n">I</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;I&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        <span class="n">E</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;IERR&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
        <span class="n">TwoDMode</span><span class="o">=</span><span class="bp">False</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="c">#2D data</span>
            <span class="n">TwoDMode</span><span class="o">=</span><span class="bp">True</span>
            <span class="n">PSI</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getdata</span><span class="p">(</span><span class="s">&#39;PSI&#39;</span><span class="p">,</span><span class="n">dataset</span><span class="o">=</span><span class="s">&#39;original&#39;</span><span class="p">)</span>
            <span class="c">#we need to recalculate the result in two dimensions</span>
            <span class="c">#done by TwoDGenI function</span>
            <span class="n">I2D</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;I2D&#39;</span><span class="p">)</span>
            <span class="n">Ishow</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c">#quadrant 1 and 4 are simulated data, 2 and 3 are measured data</span>
            <span class="n">Ishow</span><span class="p">[(</span><span class="n">PSI</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">PSI</span><span class="o">&lt;=</span><span class="mi">90</span><span class="p">)]</span><span class="o">=</span><span class="n">I2D</span><span class="p">[(</span><span class="n">PSI</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">PSI</span><span class="o">&lt;=</span><span class="mi">90</span><span class="p">)]</span>
            <span class="n">Ishow</span><span class="p">[(</span><span class="n">PSI</span><span class="o">&gt;</span><span class="mi">180</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">PSI</span><span class="o">&lt;=</span><span class="mi">270</span><span class="p">)]</span><span class="o">=</span><span class="n">I2D</span><span class="p">[(</span><span class="n">PSI</span><span class="o">&gt;</span><span class="mi">180</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">PSI</span><span class="o">&lt;=</span><span class="mi">270</span><span class="p">)]</span>
            <span class="c">#xalimits=(-numpy.min(q[:,0]),numpy.max(q[:,-1]))</span>
            <span class="c">#yalimits=(-numpy.min(q[0,:]),numpy.max(q[-1,:]))</span>
            <span class="n">xmidi</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">ymidi</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">QX</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="n">ymidi</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="n">ymidi</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">QY</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">xmidi</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">xmidi</span><span class="p">]])</span>
            <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">QX</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">QX</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">QY</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">QY</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">q_ax</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="n">nhists</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">axisbg</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">),</span><span class="n">xlim</span><span class="o">=</span><span class="n">QX</span><span class="p">,</span><span class="n">ylim</span><span class="o">=</span><span class="n">QY</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;q_x, 1/m&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;q_y, 1_m&#39;</span><span class="p">)</span>
            <span class="n">imshow</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">Ishow</span><span class="p">),</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span><span class="n">origin</span><span class="o">=</span><span class="s">&#39;lower&#39;</span><span class="p">)</span>
            <span class="n">q_ax</span><span class="o">=</span><span class="n">setaxis</span><span class="p">(</span><span class="n">q_ax</span><span class="p">)</span>
            <span class="n">colorbar</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q_ax</span><span class="o">=</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="n">nhists</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">axisbg</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">),</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">AxisMargin</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AxisMargin</span><span class="p">)),</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">AxisMargin</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AxisMargin</span><span class="p">)),</span><span class="n">xscale</span><span class="o">=</span><span class="s">&#39;log&#39;</span><span class="p">,</span><span class="n">yscale</span><span class="o">=</span><span class="s">&#39;log&#39;</span><span class="p">,</span><span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;q, 1/m&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;I, 1/(m sr)&#39;</span><span class="p">)</span>
            <span class="n">q_ax</span><span class="o">=</span><span class="n">setaxis</span><span class="p">(</span><span class="n">q_ax</span><span class="p">)</span>
            <span class="n">errorbar</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">fmt</span><span class="o">=</span><span class="s">&#39;k.&#39;</span><span class="p">,</span><span class="n">ecolor</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="n">elinewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">capsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;Measured intensity&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">solid_capstyle</span><span class="o">=</span><span class="s">&#39;round&#39;</span><span class="p">,</span><span class="n">solid_joinstyle</span><span class="o">=</span><span class="s">&#39;miter&#39;</span><span class="p">)</span>
            <span class="n">grid</span><span class="p">(</span><span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span><span class="n">dashes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span><span class="n">dash_capstyle</span><span class="o">=</span><span class="s">&#39;round&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c">#xscale(&#39;log&#39;)</span>
            <span class="c">#yscale(&#39;log&#39;)</span>
            <span class="n">aq</span><span class="o">=</span><span class="n">sort</span><span class="p">(</span><span class="n">Result</span><span class="p">[</span><span class="s">&#39;Qfit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,:])</span>
            <span class="n">aI</span><span class="o">=</span><span class="n">Result</span><span class="p">[</span><span class="s">&#39;Imean&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="n">argsort</span><span class="p">(</span><span class="n">Result</span><span class="p">[</span><span class="s">&#39;Qfit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,:])]</span>
            <span class="n">plot</span><span class="p">(</span><span class="n">aq</span><span class="p">,</span><span class="n">aI</span><span class="p">,</span><span class="s">&#39;r-&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;MC Fit intensity&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="n">aq</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Result</span><span class="p">[</span><span class="s">&#39;Screps&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:])</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">aq</span><span class="p">,</span><span class="s">&#39;g-&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;MC Background level:</span><span class="se">\n\t</span><span class="s"> ({0:03.3g})&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Result</span><span class="p">[</span><span class="s">&#39;Screps&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,:])),</span><span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">leg</span><span class="o">=</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">fancybox</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">prop</span><span class="o">=</span><span class="n">textfont</span><span class="p">)</span>
        <span class="n">title</span><span class="p">(</span><span class="s">&#39;Measured vs. Fitted intensity&#39;</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">textfont</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s">&#39;x-large&#39;</span><span class="p">)</span>

        <span class="n">R_ax</span><span class="o">=</span><span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">histi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nhists</span><span class="p">):</span>
            <span class="c">#get data:</span>
            <span class="n">Hx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;Hx&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
            <span class="n">Hmid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;Hmid&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
            <span class="n">Hwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;Hwidth&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Histweight</span><span class="o">==</span><span class="s">&#39;volume&#39;</span><span class="p">:</span>
                <span class="n">Hmean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;Hmean&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
                <span class="n">vfminbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;vfminbins&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
                <span class="n">Hstd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;Hstd&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">Histweight</span><span class="o">==</span><span class="s">&#39;number&#39;</span><span class="p">:</span>
                <span class="n">Hmean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;Hnmean&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
                <span class="n">vfminbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;nfminbins&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
                <span class="n">Hstd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="n">parname</span><span class="o">=</span><span class="s">&#39;Hnstd&#39;</span><span class="p">,</span><span class="n">VariableNumber</span><span class="o">=</span><span class="n">histi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">print</span> <span class="s">&#39;Incorrect value for Histweight: should be either &quot;volume&quot; or &quot;number&quot;&#39;</span>

            <span class="c">#prep axes</span>
            <span class="k">if</span> <span class="n">Histscale</span><span class="p">[</span><span class="n">histi</span><span class="p">]</span><span class="o">==</span><span class="s">&#39;log&#39;</span><span class="p">:</span> <span class="c">#quick fix with the [0] reference. Needs fixing, this plotting function should be rewritten to support multiple variables.</span>
                <span class="n">R_ax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="n">nhists</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">histi</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">axisbg</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">),</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Hx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">AxisMargin</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Hx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AxisMargin</span><span class="p">)),</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Hmean</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AxisMargin</span><span class="p">)),</span><span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;Radius, m&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;[Rel.] Volume Fraction&#39;</span><span class="p">,</span><span class="n">xscale</span><span class="o">=</span><span class="s">&#39;log&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">R_ax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,(</span><span class="n">nhists</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">histi</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">axisbg</span><span class="o">=</span><span class="p">(</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">,</span><span class="o">.</span><span class="mi">95</span><span class="p">),</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Hx</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">AxisMargin</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Hx</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Hx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AxisMargin</span><span class="p">)),</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Hmean</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AxisMargin</span><span class="p">)),</span><span class="n">xlabel</span><span class="o">=</span><span class="s">&#39;Radius, m&#39;</span><span class="p">,</span><span class="n">ylabel</span><span class="o">=</span><span class="s">&#39;[Rel.] Volume Fraction&#39;</span><span class="p">))</span>

            <span class="n">R_ax</span><span class="p">[</span><span class="n">histi</span><span class="p">]</span><span class="o">=</span><span class="n">setaxis</span><span class="p">(</span><span class="n">R_ax</span><span class="p">[</span><span class="n">histi</span><span class="p">])</span>
            <span class="c">#fill axes</span>
            <span class="n">bar</span><span class="p">(</span><span class="n">Hx</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">Hmean</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">Hwidth</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s">&#39;orange&#39;</span><span class="p">,</span><span class="n">edgecolor</span><span class="o">=</span><span class="s">&#39;black&#39;</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;MC size histogram&#39;</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="n">Hmid</span><span class="p">,</span><span class="n">vfminbins</span><span class="p">,</span><span class="s">&#39;r--&#39;</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s">&#39;Minimum visibility limit&#39;</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">errorbar</span><span class="p">(</span><span class="n">Hmid</span><span class="p">,</span><span class="n">Hmean</span><span class="p">,</span><span class="n">Hstd</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">fmt</span><span class="o">=</span><span class="s">&#39;k.&#39;</span><span class="p">,</span><span class="n">ecolor</span><span class="o">=</span><span class="s">&#39;k&#39;</span><span class="p">,</span><span class="n">elinewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">capsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span><span class="n">ms</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">solid_capstyle</span><span class="o">=</span><span class="s">&#39;round&#39;</span><span class="p">,</span><span class="n">solid_joinstyle</span><span class="o">=</span><span class="s">&#39;miter&#39;</span><span class="p">)</span>
            <span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">fancybox</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">prop</span><span class="o">=</span><span class="n">textfont</span><span class="p">)</span>
            <span class="n">title</span><span class="p">(</span><span class="s">&#39;Radius size histogram&#39;</span><span class="p">,</span><span class="n">fontproperties</span><span class="o">=</span><span class="n">textfont</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="s">&#39;x-large&#39;</span><span class="p">)</span>
            <span class="c">#reapply limits in x</span>
            <span class="n">xlim</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Hx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">AxisMargin</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Hx</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">AxisMargin</span><span class="p">)))</span>


        <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.11</span><span class="p">,</span><span class="n">right</span><span class="o">=</span><span class="mf">0.96</span><span class="p">,</span><span class="n">top</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.23</span><span class="p">,</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.13</span><span class="p">)</span>
        </div>
    <span class="k">def</span> <span class="nf">Rangeinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ParameterRange</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span><span class="n">Parameter</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="c">#calculates the total volume or number fraction of the MC result within a given range, and returns the total numer or volume fraction and its standard deviation over all nreps as well as the first four distribution moments: mean, variance, skewness and kurtosis (Pearson&#39;s definition)</span>
        <span class="c">#will use the &quot;Histweight&quot; parameter for determining whether to return the volume or number-weighted values.</span>
        <span class="c">#input arguments are: ParameterRange (the radius range in which the moments are to be calculated)</span>
        <span class="c">#Parameter: Which shape parameter the moments are to be calculated for (e.g. 0=width, 1=length, 2=orientation)</span>
        <span class="c">#returns a 4-by-2 array, with the values and their sample standard deviations over all Nreps</span>
        <span class="n">Rrep</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Rrep&#39;</span><span class="p">)</span>
        <span class="n">Ncontrib</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">Rrep</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">NRval</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">Rrep</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Nreps</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">Rrep</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Rpfactor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Rpfactor&#39;</span><span class="p">)</span>
        <span class="n">Memsave</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Memsave&#39;</span><span class="p">)</span>
        <span class="n">drhosqr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;drhosqr&#39;</span><span class="p">)</span>
        <span class="n">Histbins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histbins&#39;</span><span class="p">)</span>
        <span class="n">Histscale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histscale&#39;</span><span class="p">)</span>
        <span class="n">Histweight</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Histweight&#39;</span><span class="p">)</span>
        <span class="n">Bounds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">getpar</span><span class="p">(</span><span class="s">&#39;Bounds&#39;</span><span class="p">)</span>
        
        <span class="c">#ov = zeros(shape(Rrep)) #observability</span>
        <span class="n">Vf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Vf&#39;</span><span class="p">)</span> <span class="c">#volume fraction for each contribution</span>
        <span class="n">Nf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Nf&#39;</span><span class="p">)</span> <span class="c">#number fraction for each contribution</span>
        <span class="n">Vft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Vft&#39;</span><span class="p">)</span> <span class="c">#total volume fractions</span>
        <span class="n">Nft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Nft&#39;</span><span class="p">)</span> <span class="c">#total number </span>
        <span class="n">Screps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getresult</span><span class="p">(</span><span class="s">&#39;Screps&#39;</span><span class="p">)</span> <span class="c">#Intensity scaling factors for matching to the experimental scattering pattern (Amplitude A and flat background term b, defined in the paper)</span>

        <span class="n">Val</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nreps</span><span class="p">)</span> <span class="c">#total value</span>
        <span class="n">Mu</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nreps</span><span class="p">)</span> <span class="c">#moments..</span>
        <span class="n">Var</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nreps</span><span class="p">)</span> <span class="c">#moments..</span>
        <span class="n">Skw</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nreps</span><span class="p">)</span> <span class="c">#moments..</span>
        <span class="n">Krt</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nreps</span><span class="p">)</span> <span class="c">#moments..</span>

        <span class="c">#loop over each repetition</span>
        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nreps</span><span class="p">):</span>
            <span class="n">Rset</span> <span class="o">=</span> <span class="n">Rrep</span><span class="p">[:,</span><span class="n">Parameter</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="c">#the single set of R for this calculation</span>
            <span class="n">validi</span><span class="o">=</span><span class="p">(</span><span class="n">Rset</span><span class="o">&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ParameterRange</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">Rset</span><span class="o">&lt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ParameterRange</span><span class="p">))</span>
            <span class="n">Rset</span><span class="o">=</span><span class="n">Rset</span><span class="p">[</span><span class="n">validi</span><span class="p">]</span>
            <span class="n">Vset</span> <span class="o">=</span> <span class="n">Vf</span><span class="p">[</span><span class="n">validi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="c">#compensated volume for each sphere in the set</span>
            <span class="n">Nset</span> <span class="o">=</span> <span class="n">Nf</span><span class="p">[</span><span class="n">validi</span><span class="p">,</span><span class="n">ri</span><span class="p">]</span> <span class="c">#compensated volume for each sphere in the set</span>

            <span class="k">if</span> <span class="n">Histweight</span><span class="o">==</span><span class="s">&#39;volume&#39;</span><span class="p">:</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="p">)</span>
                <span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Rset</span><span class="o">*</span><span class="n">Vset</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="p">)</span>
                <span class="n">Var</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Rset</span><span class="o">-</span><span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Vset</span> <span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="p">)</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Var</span><span class="p">[</span><span class="n">ri</span><span class="p">]))</span>
                <span class="n">Skw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Rset</span><span class="o">-</span><span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">Vset</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">Krt</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Rset</span><span class="o">-</span><span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">Vset</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">Histweight</span><span class="o">==</span><span class="s">&#39;number&#39;</span><span class="p">:</span>
                <span class="n">Val</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Nset</span><span class="p">)</span>
                <span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Rset</span><span class="o">*</span><span class="n">Nset</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">Nset</span><span class="p">)</span>
                <span class="n">Var</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Rset</span><span class="o">-</span><span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">Nset</span> <span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">Nset</span><span class="p">)</span>
                <span class="n">sigma</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Var</span><span class="p">[</span><span class="n">ri</span><span class="p">]))</span>
                <span class="n">Skw</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Rset</span><span class="o">-</span><span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">Nset</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Nset</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">Krt</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="p">(</span><span class="n">Rset</span><span class="o">-</span><span class="n">Mu</span><span class="p">[</span><span class="n">ri</span><span class="p">])</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">Nset</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">Nset</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;Error in moment calculation, unrecognised Histweight value&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Val</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Mu</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Mu</span><span class="p">,</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Var</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Var</span><span class="p">,</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Skw</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Skw</span><span class="p">,</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)],</span>
                <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Krt</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Krt</span><span class="p">,</span><span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)]])</span>
        

<span class="c">#some quick pickle functions to make my life easier</span>
</div>
<span class="k">def</span> <span class="nf">pickle_read</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="c">#nargs can be 1-4, indicates number of output variables, if it is even possible to extract more from pickle</span>
    <span class="n">fh</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">O</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">O</span>

<span class="k">def</span> <span class="nf">pickle_write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">DBlock</span><span class="p">):</span>
    <span class="c">#writes DBlock to a file</span>
    <span class="n">fh</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">DBlock</span><span class="p">,</span><span class="n">fh</span><span class="p">)</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span>

<div class="viewcode-block" id="binning_array"><a class="viewcode-back" href="../code.html#McSAS.binning_array">[docs]</a><span class="k">def</span> <span class="nf">binning_array</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">PSI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">IERR</span><span class="p">,</span><span class="n">S</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="s">&quot;this function applies a simple S-by-S binning routine on images. Calculates new error based on old error superseded by standard deviation in a bin&quot;</span>
    <span class="k">def</span> <span class="nf">isodd</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c">#checks if a value is even or odd</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">x</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ddi</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q</span><span class="p">,</span><span class="s">&#39;PSI&#39;</span><span class="p">:</span><span class="n">PSI</span><span class="p">,</span><span class="s">&#39;I&#39;</span><span class="p">:</span><span class="n">I</span><span class="p">,</span><span class="s">&#39;IERR&#39;</span><span class="p">:</span><span class="n">IERR</span><span class="p">}</span>
    
    <span class="n">sq</span><span class="o">=</span><span class="n">shape</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isodd</span><span class="p">(</span><span class="n">sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c">#trim edge</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">ddi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">ddi</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="n">ddi</span><span class="p">[</span><span class="n">it</span><span class="p">][</span><span class="mi">1</span><span class="p">:,:]</span>
    <span class="k">if</span> <span class="n">isodd</span><span class="p">(</span><span class="n">sq</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c">#trim edge</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">ddi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">ddi</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="n">ddi</span><span class="p">[</span><span class="n">it</span><span class="p">][:,</span><span class="mi">1</span><span class="p">:]</span>
    <span class="c">#now we can do n-by-n binning</span>
    <span class="n">sq</span><span class="o">=</span><span class="n">shape</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">qo</span><span class="o">=</span><span class="n">zeros</span><span class="p">((</span><span class="n">sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">S</span><span class="p">,</span><span class="n">sq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">S</span><span class="p">))</span>
    <span class="n">ddo</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;Q&#39;</span><span class="p">:</span><span class="n">qo</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="s">&#39;PSI&#39;</span><span class="p">:</span><span class="n">qo</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="s">&#39;I&#39;</span><span class="p">:</span><span class="n">qo</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="s">&#39;IERR&#39;</span><span class="p">:</span><span class="n">qo</span><span class="o">.</span><span class="n">copy</span><span class="p">()}</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;Q&#39;</span><span class="p">,</span><span class="s">&#39;PSI&#39;</span><span class="p">,</span><span class="s">&#39;I&#39;</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">S</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">S</span><span class="p">):</span>
                <span class="n">ddo</span><span class="p">[</span><span class="n">it</span><span class="p">][</span><span class="n">ri</span><span class="p">,</span><span class="n">ci</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ddi</span><span class="p">[</span><span class="n">it</span><span class="p">][</span><span class="n">S</span><span class="o">*</span><span class="n">ri</span><span class="p">:(</span><span class="n">S</span><span class="o">*</span><span class="n">ri</span><span class="o">+</span><span class="n">S</span><span class="p">),</span><span class="n">S</span><span class="o">*</span><span class="n">ci</span><span class="p">:(</span><span class="n">S</span><span class="o">*</span><span class="n">ci</span><span class="o">+</span><span class="n">S</span><span class="p">)])</span>
        
    <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">S</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">S</span><span class="p">):</span>
            <span class="n">meanE</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">ddi</span><span class="p">[</span><span class="s">&#39;IERR&#39;</span><span class="p">][</span><span class="n">S</span><span class="o">*</span><span class="n">ri</span><span class="p">:(</span><span class="n">S</span><span class="o">*</span><span class="n">ri</span><span class="o">+</span><span class="n">S</span><span class="p">),</span><span class="n">S</span><span class="o">*</span><span class="n">ci</span><span class="p">:(</span><span class="n">S</span><span class="o">*</span><span class="n">ci</span><span class="o">+</span><span class="n">S</span><span class="p">)])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">stdI</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddi</span><span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">][</span><span class="n">S</span><span class="o">*</span><span class="n">ri</span><span class="p">:(</span><span class="n">S</span><span class="o">*</span><span class="n">ri</span><span class="o">+</span><span class="n">S</span><span class="p">),</span><span class="n">S</span><span class="o">*</span><span class="n">ci</span><span class="p">:(</span><span class="n">S</span><span class="o">*</span><span class="n">ci</span><span class="o">+</span><span class="n">S</span><span class="p">)])</span><span class="c">#sample standard deviation</span>
            <span class="c">#stdI=0</span>
            <span class="n">ddo</span><span class="p">[</span><span class="s">&#39;IERR&#39;</span><span class="p">][</span><span class="n">ri</span><span class="p">,</span><span class="n">ci</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">meanE</span><span class="p">,</span><span class="n">stdI</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ddo</span>
</div>
<span class="k">def</span> <span class="nf">binning_1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">E</span><span class="o">=</span><span class="p">[],</span><span class="n">Nbins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span><span class="n">Stats</span><span class="o">=</span><span class="s">&#39;STD&#39;</span><span class="p">):</span>
    <span class="c">#python implementation of an unweighted binning routine. The intensities are sorted across bins of equal size. If error provided is empty, the standard deviation of the intensities in the bins are computed.</span>
    <span class="c">#let&#39;s make sure the input is consistent</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">!=</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Incompatible sizes of q and I&quot;</span>
        <span class="k">return</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">&quot;Size of E is not identical to q and I&quot;</span>
        <span class="k">return</span>

    <span class="c">#flatten q, I and E</span>
    <span class="n">q</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">E</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>

    <span class="c">#define the bin edges and centres, and find out the stepsize while we&#39;re at it. Probably, there is no need for knowing the edges...</span>
    <span class="n">qbin_edges</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="n">Nbins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">stepsize</span><span class="o">=</span><span class="n">qbin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">qbin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">qbin_centres</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">stepsize</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">stepsize</span><span class="p">,</span><span class="n">Nbins</span><span class="p">)</span>
    
    <span class="c">#sort q, let I and E follow sort</span>
    <span class="n">sort_ind</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
    <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>
    <span class="n">Ibin</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>
    <span class="n">Ebin</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>    
    <span class="n">SDbin</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>    
    <span class="n">SEbin</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>    
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">sort_ind</span><span class="p">]</span>

    <span class="c">#now we can fill the bins</span>
    <span class="k">for</span> <span class="n">Bini</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nbins</span><span class="p">):</span>
        <span class="c">#limit ourselves to only the bits we&#39;re interested in:</span>
        <span class="n">lim_bool_array</span><span class="o">=</span><span class="p">((</span><span class="n">q</span><span class="o">&gt;</span><span class="p">(</span><span class="n">qbin_centres</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">-</span><span class="n">stepsize</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">qbin_centres</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">+</span><span class="n">stepsize</span><span class="p">)))</span>
        <span class="n">I_to_bin</span><span class="o">=</span><span class="n">I</span><span class="p">[</span><span class="n">lim_bool_array</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">E_to_bin</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">lim_bool_array</span><span class="p">])</span>

        <span class="c">#find out the weighting factors for each q,I,E-pair in the array  </span>
        <span class="n">weight_fact</span><span class="o">=</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">I_to_bin</span><span class="p">))</span>

        <span class="c">#sum the intensities in one bin and normalize by number of pixels</span>
        <span class="n">Ibin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">I_to_bin</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">);</span> 

        

        <span class="c">#now we deal with the Errors:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span> <span class="c">#if we have errors supplied from outside</span>
            <span class="c">#standard error calculation:</span>
            <span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">E_to_bin</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">weight_fact</span><span class="p">))</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">)</span>
            <span class="c">#Ebin2[Bini]=sqrt(sum((E_to_bin*weight_fact)**2))/sum(weight_fact) old, incorrect</span>
            <span class="k">if</span> <span class="n">Stats</span><span class="o">==</span><span class="s">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">I_to_bin</span><span class="o">-</span><span class="n">Ibin</span><span class="p">[</span><span class="n">Bini</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c">#according to the definition of sample-standard deviation</span>
                <span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">],</span><span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">))]))</span> <span class="c">#maximum between standard error and Poisson statistics</span>

        <span class="k">else</span><span class="p">:</span>           
            <span class="c">#calculate the standard deviation of the intensity in the bin both for samples with supplied error as well as for those where the error is supposed to be calculated</span>
            <span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">I_to_bin</span><span class="o">-</span><span class="n">Ibin</span><span class="p">[</span><span class="n">Bini</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c">#according to the definition of sample-standard deviation</span>
            <span class="c">#calculate standard error by dividing the standard error by the square root of the number of measurements</span>
            <span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">qbin_centres</span><span class="p">,</span><span class="n">Ibin</span><span class="p">,</span><span class="n">SEbin</span>

<span class="k">def</span> <span class="nf">binning_weighted_1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">E</span><span class="o">=</span><span class="p">[],</span><span class="n">Nbins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span><span class="n">Stats</span><span class="o">=</span><span class="s">&#39;SE&#39;</span><span class="p">):</span>
    <span class="c">#USAGE: qbin,Ibin,Ebin=binning_weighted_1D(q,I,E=[],Nbins=200,Stats=&#39;SE&#39;):</span>
    <span class="c">#python implementation of the binning routine written in Matlab. The intensities are divided across the q-range in bins of equal size. The intensities of a pixel are divided between the two neighbouring bins depending on the distances to the centres. If error provided is empty, the standard deviation of the intensities in the bins are computed.</span>
    <span class="c">#optional input arguments:</span>
    <span class="c">#   Nbins: integer indicating the number of bins to divide the intensity over. Alternatively, this can be an array of equidistant bin centres. If you go this route, depending on the range, not all intensity may be counted.</span>
    <span class="c">#   Stats: can be set to &#39;auto&#39;. This takes the maximum error between supplied Poisson statistics error-based errors or the standard error. </span>
    <span class="c">#Written by Brian R. Pauw, 2011, released under BSD open source license.</span>
    <span class="c">#let&#39;s make sure the input is consistent</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">!=</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Incompatible lengths of q and I, q must be of the same number of elements as I&quot;</span>
        <span class="k">return</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
        <span class="k">print</span> <span class="s">&quot;Size of E is not identical to q and I&quot;</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Stats</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">!=</span><span class="s">&#39;std&#39;</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Stats</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">!=</span><span class="s">&#39;poisson&#39;</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Stats</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">!=</span><span class="s">&#39;se&#39;</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Stats</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">!=</span><span class="s">&#39;auto&#39;</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;Statistics can only be set to &#39;SE&#39; (default), or &#39;auto&#39;. </span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">print</span> <span class="s">&quot;Only use &#39;auto&#39; for photon-counting detectors, selects largest error between SE and Poisson.</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">print</span> <span class="s">&quot;If errors are supplied, standard errors are not calculated except in the case of &#39;auto&#39; &quot;</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Nbins</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;number of bins, Nbins, is smaller than one. I need at least one bin to fill&quot;</span>
            <span class="k">return</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Nbins is larger than one value. Assuming that an equidistant list of bin centres has been supplied&quot;</span>

    <span class="c">#flatten q, I and E</span>
    <span class="n">q</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">I</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">E</span><span class="o">=</span><span class="n">reshape</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c">#define the bin edges and centres, and find out the stepsize while we&#39;re at it. Probably, there is no need for knowing the edges...</span>
        <span class="n">qbin_edges</span><span class="p">,</span><span class="n">stepsize</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="n">Nbins</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">retstep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="c">#do not use qbin_edges!</span>
        <span class="c">#stepsize=qbin_edges[1]-qbin_edges[0]</span>
        <span class="n">qbin_centres</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">stepsize</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">stepsize</span><span class="p">,</span><span class="n">Nbins</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">&gt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Nbins</span><span class="p">))</span><span class="o">|</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">&lt;</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)):</span>
            <span class="k">print</span> <span class="s">&quot;Bin centres supplied do not overlap with the q-range, cannot continue&quot;</span>
            <span class="k">return</span>
        <span class="n">qbin_centres</span><span class="o">=</span><span class="n">sort</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>
        <span class="n">stepsize</span><span class="o">=</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">qbin_centres</span><span class="p">))</span>
        <span class="n">Nbins</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">qbin_centres</span><span class="p">)</span>

    <span class="c">#initialize output matrices</span>
    <span class="n">Ibin</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>
    <span class="n">SDbin</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>    
    <span class="n">SEbin</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nbins</span><span class="p">)</span>    

    <span class="c">#now we can fill the bins</span>
    <span class="k">for</span> <span class="n">Bini</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nbins</span><span class="p">):</span>
        <span class="c">#limit ourselves to only the bits we&#39;re interested in:</span>
        <span class="n">lim_bool_array</span><span class="o">=</span><span class="p">((</span><span class="n">q</span><span class="o">&gt;</span><span class="p">(</span><span class="n">qbin_centres</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">-</span><span class="n">stepsize</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="p">(</span><span class="n">qbin_centres</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">+</span><span class="n">stepsize</span><span class="p">)))</span>
        <span class="n">q_to_bin</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">lim_bool_array</span><span class="p">]</span>
        <span class="n">I_to_bin</span><span class="o">=</span><span class="n">I</span><span class="p">[</span><span class="n">lim_bool_array</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">E_to_bin</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">lim_bool_array</span><span class="p">]</span>

        <span class="c">#find out the weighting factors for each q,I,E-pair in the array  </span>
        <span class="n">q_dist</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">q_to_bin</span><span class="o">-</span><span class="n">qbin_centres</span><span class="p">[</span><span class="n">Bini</span><span class="p">])</span>
        <span class="n">weight_fact</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q_dist</span><span class="o">/</span><span class="n">stepsize</span><span class="p">)</span>

        <span class="c">#sum the intensities in one bin</span>
        <span class="n">Ibin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">I_to_bin</span><span class="o">*</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">);</span> 

        <span class="c">#now we deal with the Errors:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span> <span class="c">#if we have errors supplied from outside</span>
            <span class="c">#standard error calculation:</span>
            <span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">E_to_bin</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">weight_fact</span><span class="p">))</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">)</span>
            <span class="c">#Ebin2[Bini]=sqrt(sum((E_to_bin*weight_fact)**2))/sum(weight_fact) old, incorrect</span>
            <span class="k">if</span> <span class="n">Stats</span><span class="o">==</span><span class="s">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">I_to_bin</span><span class="o">-</span><span class="n">Ibin</span><span class="p">[</span><span class="n">Bini</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c">#according to the definition of sample-standard deviation</span>
                <span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">array</span><span class="p">([</span><span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">],</span><span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">))]))</span> <span class="c">#maximum between standard error and Poisson statistics</span>
        <span class="k">else</span><span class="p">:</span>           
            <span class="c">#calculate the standard deviation of the intensity in the bin both for samples with supplied error as well as for those where the error is supposed to be calculated</span>
            <span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">I_to_bin</span><span class="o">-</span><span class="n">Ibin</span><span class="p">[</span><span class="n">Bini</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c">#according to the definition of sample-standard deviation</span>
            <span class="c">#calculate standard error by dividing the standard error by the square root of the number of measurements</span>
            <span class="n">SEbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">=</span><span class="n">SDbin</span><span class="p">[</span><span class="n">Bini</span><span class="p">]</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">weight_fact</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qbin_centres</span><span class="p">,</span><span class="n">Ibin</span><span class="p">,</span><span class="n">SEbin</span>
        
    
<span class="c">##general functions</span>
<span class="k">def</span> <span class="nf">csqr</span><span class="p">(</span><span class="n">Sc</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Ic</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
    <span class="c">#least-squares error for use with scipy.optimize.leastsq</span>
    <span class="n">cs</span><span class="o">=</span><span class="p">(</span><span class="n">I</span><span class="o">-</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="o">-</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">E</span>
    <span class="c">#print &quot;Size E&quot;,size(E)</span>
    <span class="c">#print &quot;Sc: %f, %f&quot; %(Sc[0],Sc[1])</span>
    <span class="k">return</span> <span class="n">cs</span>

<span class="k">def</span> <span class="nf">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Ic</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">,</span><span class="n">OutputI</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c">#new version, using leastsq and csqr, speed improvement of over a factor of 10 w.r.t. V1&#39;s use in the MC algorithm</span>
    <span class="c">#optimizes the scaling and background factor to match Ic closest to I. returns an array with scaling factors. Input Sc has to be a two-element array wiht the scaling and background   </span>
    <span class="c">#initial guesses. No bounds at the moment are applied, except that the intensity scaling has to be positive.</span>
    <span class="n">Sc</span><span class="p">,</span><span class="n">success</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">csqr</span><span class="p">,</span><span class="n">Sc</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">Ic</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">E</span><span class="o">.</span><span class="n">flatten</span><span class="p">()),</span><span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c">#print &quot;Sc: %f, %f&quot; %(Sc[0],Sc[1])</span>
    <span class="n">cval</span><span class="o">=</span><span class="n">csqr_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">E</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">OutputI</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Sc</span><span class="p">,</span><span class="n">cval</span><span class="p">,</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Sc</span><span class="p">,</span><span class="n">cval</span>

<span class="k">def</span> <span class="nf">csqr_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Ic</span><span class="p">,</span><span class="n">E</span><span class="p">):</span>
    <span class="c">#least-squares for data with known error, size of parameter-space not taken into account</span>
    <span class="n">cs</span><span class="o">=</span><span class="nb">sum</span><span class="p">(((</span><span class="n">I</span><span class="o">-</span><span class="n">Ic</span><span class="p">)</span><span class="o">/</span><span class="n">E</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cs</span>
<span class="c">#</span>
<span class="k">def</span> <span class="nf">Iopt_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Ic</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">,</span><span class="n">OutputI</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">Background</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="c">#old version, using fmin and csqr_v1</span>
    <span class="c">#optimizes the scaling and background factor to match Ic closest to I. returns an array with scaling factors. Input Sc has to be a two-element array wiht the scaling and background   </span>
    <span class="c">#initial guesses. No bounds at the moment are applied, except that the intensity scaling has to be positive.</span>
    <span class="c">#Background can be set to False to just find the scaling factor.</span>
    <span class="k">if</span> <span class="n">Background</span><span class="p">:</span>
        <span class="n">Sc</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="k">lambda</span> <span class="n">Sc</span><span class="p">:</span> <span class="n">csqr_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">E</span><span class="p">),</span><span class="n">Sc</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cval</span><span class="o">=</span><span class="n">csqr_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">E</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">Sc</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="k">lambda</span> <span class="n">Sc</span><span class="p">:</span> <span class="n">csqr_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="p">,</span><span class="n">E</span><span class="p">),</span><span class="n">Sc</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">cval</span><span class="o">=</span><span class="n">csqr_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="p">,</span><span class="n">E</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">OutputI</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Sc</span><span class="p">,</span><span class="n">cval</span><span class="p">,</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Ic</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Sc</span><span class="p">,</span><span class="n">cval</span>
<span class="c">#</span>
<span class="c">#########################################DEAD CODE?################################################</span>

<span class="c">#older code, may need to be updated before it can or should be used again.</span>

<span class="c">#Monte-carlo procedure for cylinders</span>
<span class="k">def</span> <span class="nf">MCFit_cyl_RadialIsotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Ncyl</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span><span class="n">Bounds</span><span class="o">=</span><span class="p">[],</span><span class="n">Convcrit</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">Rpfactor</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">Maxiter</span><span class="o">=</span><span class="mf">1e5</span><span class="p">,</span><span class="n">R1Prior</span><span class="o">=</span><span class="p">[],</span><span class="n">R2Prior</span><span class="o">=</span><span class="p">[],</span><span class="n">Oprior</span><span class="o">=</span><span class="p">[],</span><span class="n">Qlimits</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span><span class="n">MaskNegI</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">OutputI</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">R2IsAspect</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">OutputDetails</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c">#Bound has to be a 4-element vector, with bounds for R1, R2</span>
    <span class="c">#rewrite of the monte-carlo method previously implemented in Matlab. Simpler form, but open source might mean slight improvements.</span>
    <span class="c">#initialise parameters</span>
    <span class="c">#Convcrit=1 #reasonable value for poisson weighting. any lower than this and we would be fitting noise</span>
    <span class="c">#OutputI can be set to True only if MaskNeg is not True</span>
    <span class="n">Weighting</span><span class="o">=</span><span class="s">&#39;Poisson&#39;</span> <span class="c">#only one implemented</span>
    <span class="n">Method</span><span class="o">=</span><span class="s">&#39;Randmove&#39;</span> <span class="c">#only one implemented</span>
    <span class="k">if</span> <span class="n">MaskNegI</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">OutputI</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span> <span class="c">#no q-limits supplied</span>
        <span class="n">Qlimits</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span> <span class="c">#only lower q limit supplied</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span> <span class="c">#integer supplied, removing a number of values</span>
            <span class="n">Qlimits</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">Qlimits</span><span class="p">]</span>
        <span class="n">Qlimits</span><span class="o">=</span><span class="n">append</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c">#make sure they are in the right order</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span> <span class="c">#integer supplied, removing a number of values</span>
            <span class="n">Qlimits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span> <span class="c">#integer supplied, removing a number of values</span>
            <span class="n">Qlimits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">Qlimits</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Qlimits</span><span class="p">)])</span>
    <span class="c">#apply limits</span>
    <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">[(</span><span class="n">q</span><span class="o">&gt;=</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">[(</span><span class="n">q</span><span class="o">&gt;=</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">[(</span><span class="n">q</span><span class="o">&gt;=</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">Qlimits</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="c">#optional masking of negative intensity</span>
    <span class="k">if</span> <span class="n">MaskNegI</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">I</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">[</span><span class="n">I</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">[</span><span class="n">I</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">Bounds</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#if the bounds are not supplied, make a good guess</span>
        <span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="n">pi</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">),</span><span class="n">pi</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)])</span> <span class="c">#reasonable, but not necessarily correct, parameters</span>
        <span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&#39;Bounds not provided, so set related to minimum and maximum q. Lower and upper bounds are {0} and {1} for R1 as well as R2&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c">#Rpower=2 #squared results in most reasonable end result. none=3, linear=2.5, squared=2, cubed=1.5, fourth=1. This reduces the volume dependency in the calculation leading to quicker convergence</span>
    <span class="c">#Maxiter=1e6</span>

    <span class="c">#intialise variables</span>
    <span class="n">FFsqrset</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Vset</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Niter</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">Conval</span><span class="o">=</span><span class="n">inf</span>
    <span class="n">Ri</span><span class="o">=</span><span class="mi">0</span> <span class="c">#index of sphere to change. We&#39;ll sequentially change spheres, which is perfectly random since they are in random order.</span>
    
    <span class="c">#generate initial set of spheres</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">R1set</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]),</span><span class="n">Ncyl</span><span class="p">)</span>
        <span class="n">R2set</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span><span class="n">Ncyl</span><span class="p">)</span>
        <span class="n">Oset</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]),</span><span class="n">Ncyl</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Ncyl</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">Ncyl</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">)</span>
        <span class="n">R1set</span><span class="o">=</span><span class="n">R1Prior</span>
        <span class="n">R2set</span><span class="o">=</span><span class="n">R2Prior</span>
        <span class="n">Oset</span><span class="o">=</span><span class="n">OPrior</span>
    <span class="k">elif</span> <span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">)</span><span class="o">==</span><span class="n">Ncyl</span><span class="p">:</span>
        <span class="n">R1set</span><span class="o">=</span><span class="n">R1Prior</span>
        <span class="n">R2set</span><span class="o">=</span><span class="n">R2Prior</span>
        <span class="n">Oset</span><span class="o">=</span><span class="n">OPrior</span>
    <span class="k">elif</span> <span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">)</span><span class="o">&lt;</span><span class="n">Ncyl</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;size of prior is smaller than Ncyl. duplicating random prior values&quot;</span>
        <span class="c">#while size(Prior)&lt;Nsph:</span>
        <span class="n">Addi</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">),</span><span class="n">size</span><span class="o">=</span><span class="n">Ncyl</span><span class="o">-</span><span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">))</span>
        <span class="n">R1set</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">R1Prior</span><span class="p">,</span><span class="n">R1Prior</span><span class="p">[</span><span class="n">Addi</span><span class="p">]))</span>
        <span class="n">R2set</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">R2Prior</span><span class="p">,</span><span class="n">R2Prior</span><span class="p">[</span><span class="n">Addi</span><span class="p">]))</span>
        <span class="n">Oset</span><span class="o">=</span><span class="n">concatenate</span><span class="p">((</span><span class="n">OPrior</span><span class="p">,</span><span class="n">OPrior</span><span class="p">[</span><span class="n">Addi</span><span class="p">]))</span>
        <span class="k">print</span> <span class="s">&quot;size now:&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">)</span><span class="o">&gt;</span><span class="n">Ncyl</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Size of prior is larger than Ncyl. removing random prior values&quot;</span>
        <span class="n">Remi</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1Prior</span><span class="p">),</span><span class="n">size</span><span class="o">=</span><span class="n">Ncyl</span><span class="p">)</span> <span class="c">#remaining choices</span>
        <span class="n">R1set</span><span class="o">=</span><span class="n">R1Prior</span><span class="p">[</span><span class="n">Remi</span><span class="p">]</span>
        <span class="n">R2set</span><span class="o">=</span><span class="n">R2Prior</span><span class="p">[</span><span class="n">Remi</span><span class="p">]</span>
        <span class="n">Oset</span><span class="o">=</span><span class="n">OPrior</span><span class="p">[</span><span class="n">Remi</span><span class="p">]</span>
        <span class="k">print</span> <span class="s">&quot;size now:&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">)</span>
    
    <span class="n">Arange</span><span class="o">=</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Ncyl</span><span class="p">))</span> <span class="c">#indices to array values, we&#39;ll need this later for some logical indexing operations</span>

    <span class="c">#calculate their form factors</span>
    <span class="c">#FFset=FF_sph_1D(q,Rset)</span>
    <span class="n">FFsqrset</span><span class="o">=</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">),</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
    <span class="k">print</span> <span class="s">&quot;Generating initial set of cylinders...&quot;</span>
    <span class="n">now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
            <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Radial_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">R2set</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">*</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Oset</span><span class="p">[</span><span class="n">Ri</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Radial_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">R2set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Oset</span><span class="p">[</span><span class="n">Ri</span><span class="p">]]))</span>
    <span class="k">print</span> <span class="s">&quot;average time (s) per cylinder: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">now</span><span class="p">)</span><span class="o">/</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
        <span class="n">Vset</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1set</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">R2set</span><span class="o">*</span><span class="n">R1set</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Vset</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1set</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">R2set</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
    <span class="c">#calculate the intensities</span>
    <span class="n">Iset</span><span class="o">=</span><span class="n">FFsqrset</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFsqrset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
    <span class="n">Vst</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c">#total volume squared</span>
    <span class="n">It</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c">#the total intensity</span>
    <span class="c">#optimize the intensities and calculate convergence criterium</span>
    <span class="n">Sc</span><span class="p">,</span><span class="n">Conval1</span><span class="o">=</span><span class="n">Iopt_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">It</span><span class="o">/</span><span class="n">Vst</span><span class="p">,</span><span class="n">E</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="c">#V1 is more robust w.r.t. a poor initial guess</span>
    <span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">It</span><span class="o">/</span><span class="n">Vst</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">)</span> <span class="c">#reoptimize with V2, there might be a slight discrepancy in the residual definitions of V1 and V2 which would prevent optimization.</span>
    <span class="c">#print &quot;Initial conval V1&quot;,Conval1</span>
    <span class="k">print</span> <span class="s">&quot;Initial conval V2&quot;</span><span class="p">,</span><span class="n">Conval</span>
    <span class="c">#start the MC procedure</span>
    <span class="n">Now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">Nmoves</span><span class="o">=</span><span class="mi">0</span> <span class="c">#tracking the number of moves</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">Conval</span><span class="o">&gt;</span><span class="n">Convcrit</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">Niter</span><span class="o">&lt;</span><span class="n">Maxiter</span><span class="p">):</span>
        <span class="n">R1t</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">R2t</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Ot</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">6</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
            <span class="n">Fst</span><span class="o">=</span><span class="n">Integrate_Shape_as_Radial_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1t</span><span class="p">,</span><span class="n">R2t</span><span class="o">*</span><span class="n">R1t</span><span class="p">,</span><span class="n">Ot</span><span class="p">]))</span>
            <span class="n">Vtt</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1t</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">R1t</span><span class="o">*</span><span class="n">R2t</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Fst</span><span class="o">=</span><span class="n">Integrate_Shape_as_Radial_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1t</span><span class="p">,</span><span class="n">R2t</span><span class="p">,</span><span class="n">Ot</span><span class="p">]))</span>
            <span class="n">Vtt</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1t</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">R2t</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
        <span class="n">Itt</span><span class="o">=</span><span class="p">(</span><span class="n">Fst</span><span class="o">*</span><span class="n">Vtt</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="c">#calculate new total intensity</span>
        <span class="n">Itest</span><span class="o">=</span><span class="p">(</span><span class="n">It</span><span class="o">-</span><span class="n">Iset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">+</span><span class="n">Itt</span><span class="p">)</span> <span class="c">#we do subtractions and additions, which give us another factor 2 improvement in speed over summation and is much more scalable</span>
        <span class="n">Vstest</span><span class="o">=</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Vst</span><span class="p">)</span><span class="o">-</span><span class="n">Vset</span><span class="p">[</span><span class="n">Ri</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Vtt</span><span class="o">**</span><span class="mi">2</span>
        <span class="c">#optimize intensity and calculate convergence criterium</span>
        <span class="n">Sct</span><span class="p">,</span><span class="n">Convalt</span><span class="o">=</span><span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Itest</span><span class="o">/</span><span class="n">Vstest</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">)</span><span class="c">#using version two here for a &gt;10 times speed improvement</span>
        <span class="c">#test if the radius change is an improvement:</span>
        <span class="k">if</span> <span class="n">Convalt</span><span class="o">&lt;</span><span class="n">Conval</span><span class="p">:</span> <span class="c">#it&#39;s better</span>
            <span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">R2set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Oset</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Iset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:],</span><span class="n">It</span><span class="p">,</span><span class="n">Vset</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Vst</span><span class="p">,</span><span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="p">(</span><span class="n">R1t</span><span class="p">,</span><span class="n">R2t</span><span class="p">,</span><span class="n">Ot</span><span class="p">,</span><span class="n">Itt</span><span class="p">,</span><span class="n">Itest</span><span class="p">,</span><span class="n">Vtt</span><span class="p">,</span><span class="n">Vstest</span><span class="p">,</span><span class="n">Sct</span><span class="p">,</span><span class="n">Convalt</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;Improvement in iteration number </span><span class="si">%i</span><span class="s">, convergence value </span><span class="si">%f</span><span class="s"> of </span><span class="si">%f</span><span class="se">\r</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Niter</span><span class="p">,</span><span class="n">Conval</span><span class="p">,</span><span class="n">Convcrit</span><span class="p">),</span>
            <span class="n">Nmoves</span><span class="o">+=</span><span class="mi">1</span>
        <span class="c">#else nothing to do</span>
        <span class="n">Ri</span><span class="o">+=</span><span class="mi">1</span> <span class="c">#move to next sphere in list</span>
        <span class="n">Ri</span><span class="o">=</span><span class="n">Ri</span><span class="o">%</span><span class="p">(</span><span class="n">Ncyl</span><span class="p">)</span> <span class="c">#loop if last sphere</span>
        <span class="n">Niter</span><span class="o">+=</span><span class="mi">1</span> <span class="c">#add one to the iteration number           </span>
    <span class="k">if</span> <span class="n">Niter</span><span class="o">&gt;=</span><span class="n">Maxiter</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;exited due to max. number of iterations (</span><span class="si">%i</span><span class="s">) reached&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Niter</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;Normal exit&quot;</span>
    <span class="k">print</span> <span class="s">&quot;Number of iterations per second&quot;</span><span class="p">,</span><span class="n">Niter</span><span class="o">/</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">Now</span><span class="o">+</span><span class="mf">0.001</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;Number of valid moves&quot;</span><span class="p">,</span><span class="n">Nmoves</span>
    <span class="k">print</span> <span class="s">&quot;final convergence value </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">Conval</span><span class="p">)</span>
    <span class="n">Ifinal</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Ifinal</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">)</span>    
    <span class="n">Details</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;Niter&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Niter</span>
    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;Nmoves&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Nmoves</span>
    <span class="n">Details</span><span class="p">[</span><span class="s">&#39;elapsed&#39;</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">Now</span><span class="o">+</span><span class="mf">0.001</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">OutputI</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">OutputDetails</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">R1set</span><span class="p">,</span><span class="n">R2set</span><span class="p">,</span><span class="n">Oset</span><span class="p">,(</span><span class="n">Ifinal</span><span class="o">*</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Conval</span><span class="p">,</span><span class="n">Details</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">R1set</span><span class="p">,</span><span class="n">R2set</span><span class="p">,</span><span class="n">Oset</span><span class="p">,(</span><span class="n">Ifinal</span><span class="o">*</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Conval</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">OutputDetails</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">R1set</span><span class="p">,</span><span class="n">R2set</span><span class="p">,</span><span class="n">Oset</span><span class="p">,</span><span class="n">Conval</span><span class="p">,</span><span class="n">Details</span> <span class="c">#ifinal cannot be output with variable length intensity outputs (in case of masked negative intensities or q limits)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">R1set</span><span class="p">,</span><span class="n">R2set</span><span class="p">,</span><span class="n">Oset</span><span class="p">,</span><span class="n">Conval</span> <span class="c">#ifinal cannot be output with variable length intensity outputs (in case of masked negative intensities or q limits)</span>

<span class="k">def</span> <span class="nf">Analyze_1D_Cylinder_RadiallyIsotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Bounds</span><span class="o">=</span><span class="p">[],</span><span class="n">Ncyl</span><span class="o">=</span><span class="p">[],</span><span class="n">Maxiter</span><span class="o">=</span><span class="p">[],</span><span class="n">Rpfactor</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">Nreps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">qlims</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">inf</span><span class="p">],</span><span class="n">Histbins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">Histscale</span><span class="o">=</span><span class="s">&#39;log&#39;</span><span class="p">,</span><span class="n">drhosqr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">Convcrit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">Maxntry</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">R2IsAspect</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c">#this function runs the monte-carlo fit several times, and returns bin centres, means, standard deviations and observability limits for the bins. Eventually, this may also plot. The drhosqr value can be set to the contrast (if known) so a volume fraction for each histogram bin is calculated.</span>
    <span class="c">#Rpower = 3 when Rpfactor = 1. Rpower = 3*Rpfactor</span>
    <span class="c">#for volume weighting, Rpfactor = 1.5/3</span>
    <span class="c">#Rpower = Rpfactor*3</span>
    <span class="k">if</span> <span class="n">Histscale</span><span class="o">==</span><span class="s">&#39;lin&#39;</span><span class="p">:</span>
        <span class="n">Hx1</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Histbins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
            <span class="n">Hx2</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Histbins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Hx2</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">Histbins</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Hx1</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">linspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Histbins</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
            <span class="n">Hx2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">linspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">Histbins</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Hx2</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">linspace</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="n">log10</span><span class="p">(</span><span class="n">Bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span><span class="n">Histbins</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="c">#Rmc,ConVal = MCFit_sph(q,I,E,Bounds=Bounds,Nsph=Nsph,Maxiter=Maxiter,Rpower=Rpower)</span>
    <span class="c">#if ConVal&gt;1:</span>
    <span class="c">#    print &quot;test optimisation not converging to below 1! fix first, then ask again&quot;</span>
    <span class="c">#    return</span>

    <span class="c">#q and psi limits</span>
    <span class="n">validbools</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">&gt;=</span><span class="n">qlims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&amp;</span><span class="p">(</span><span class="n">q</span><span class="o">&lt;=</span><span class="n">qlims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="n">validbools</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">validbools</span><span class="p">]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">validbools</span><span class="p">]</span>

    <span class="n">R1rep</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">Ncyl</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="n">R2rep</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">Ncyl</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="n">Orep</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">Ncyl</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="n">Vf</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">Ncyl</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="n">Vft</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="c">#Rrep[:,0]=Rmc</span>
    <span class="n">Hy1</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">Histbins</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="n">Hy2</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">Histbins</span><span class="p">,</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="c">#Hr=hist(Rmc,Hx,normed=True,weights=1/Rmc**((3-Rpower)*2))</span>
    <span class="c">#Hy[:,0]=Hr[0]</span>
    <span class="n">Irep</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">),</span><span class="n">Nreps</span><span class="p">])</span>
    <span class="c">#try optimizing Nreps times</span>
    <span class="n">bignow</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">Niters</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">Nreps</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">nr</span> <span class="ow">in</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nreps</span><span class="p">):</span>
        <span class="n">nt</span><span class="o">=</span><span class="mi">0</span>
        <span class="c">#do the thing!</span>
        <span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">R2rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">Orep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">Irep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">ConVal</span><span class="p">,</span><span class="n">Details</span><span class="o">=</span><span class="n">MCFit_cyl_RadialIsotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Ncyl</span><span class="o">=</span><span class="n">Ncyl</span><span class="p">,</span><span class="n">Bounds</span><span class="o">=</span><span class="n">Bounds</span><span class="p">,</span><span class="n">Convcrit</span><span class="o">=</span><span class="n">Convcrit</span><span class="p">,</span><span class="n">Rpfactor</span><span class="o">=</span><span class="n">Rpfactor</span><span class="p">,</span><span class="n">Maxiter</span><span class="o">=</span><span class="n">Maxiter</span><span class="p">,</span><span class="n">OutputI</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">R2IsAspect</span><span class="o">=</span><span class="n">R2IsAspect</span><span class="p">,</span><span class="n">OutputDetails</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c">#if the optimization fails, perhaps it was an uncommon failure, so we retry max 10 times to get convergence.</span>
        <span class="k">while</span> <span class="n">ConVal</span><span class="o">&gt;</span><span class="n">Convcrit</span><span class="p">:</span>
            <span class="n">nt</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">R2rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">Orep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">Irep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">ConVal</span><span class="p">,</span><span class="n">Details</span><span class="o">=</span><span class="n">MCFit_cyl_RadialIsotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Ncyl</span><span class="o">=</span><span class="n">Ncyl</span><span class="p">,</span><span class="n">Bounds</span><span class="o">=</span><span class="n">Bounds</span><span class="p">,</span><span class="n">Convcrit</span><span class="o">=</span><span class="n">Convcrit</span><span class="p">,</span><span class="n">Rpfactor</span><span class="o">=</span><span class="n">Rpfactor</span><span class="p">,</span><span class="n">Maxiter</span><span class="o">=</span><span class="n">Maxiter</span><span class="p">,</span><span class="n">OutputI</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">R2IsAspect</span><span class="o">=</span><span class="n">R2IsAspect</span><span class="p">,</span><span class="n">OutputDetails</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nt</span><span class="o">&gt;</span><span class="n">Maxntry</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;could not reach optimization criterion within {0} attempts, exiting...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Maxntry</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">Niters</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span><span class="o">=</span><span class="n">Details</span><span class="p">[</span><span class="s">&#39;Niter&#39;</span><span class="p">]</span>
        <span class="c">#absolute intensity calculation--&gt;</span>
        <span class="c">#calculate volume contribution</span>
        <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
            <span class="n">Vsa</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">*</span><span class="n">R2rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
            <span class="c">#real particle volume:</span>
            <span class="n">Vpa</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">*</span><span class="n">R2rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Vsa</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">R2rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
            <span class="c">#real particle volume:</span>
            <span class="n">Vpa</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">R2rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span>
        <span class="c">#calculate intensities without scaling:</span>

        <span class="n">FFsqrset</span><span class="o">=</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">(</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]),</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
        <span class="k">print</span> <span class="s">&quot;Generating intensity of set of cylinders...&quot;</span>
        <span class="n">now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
                <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Radial_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1rep</span><span class="p">[</span><span class="n">Ri</span><span class="p">,</span><span class="n">nr</span><span class="p">],</span><span class="n">R1rep</span><span class="p">[</span><span class="n">Ri</span><span class="p">,</span><span class="n">nr</span><span class="p">]</span><span class="o">*</span><span class="n">R2rep</span><span class="p">[</span><span class="n">Ri</span><span class="p">,</span><span class="n">nr</span><span class="p">],</span><span class="n">Orep</span><span class="p">[</span><span class="n">Ri</span><span class="p">,</span><span class="n">nr</span><span class="p">]]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Radial_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1rep</span><span class="p">[</span><span class="n">Ri</span><span class="p">,</span><span class="n">nr</span><span class="p">],</span><span class="n">R2rep</span><span class="p">[</span><span class="n">Ri</span><span class="p">,</span><span class="n">nr</span><span class="p">],</span><span class="n">Orep</span><span class="p">[</span><span class="n">Ri</span><span class="p">,</span><span class="n">nr</span><span class="p">]]))</span>
        <span class="c">#calculate the intensities</span>
        <span class="n">Ics</span><span class="o">=</span><span class="n">FFsqrset</span><span class="o">*</span><span class="p">(</span><span class="n">Vsa</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFsqrset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
        <span class="n">Icyls</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Ics</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c">#the total intensity</span>

        <span class="c">#determine scaling factor for each contribution:</span>
        <span class="n">Sci</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Icyls</span><span class="p">)</span>
        <span class="n">Sc</span><span class="p">,</span><span class="n">Cv</span><span class="o">=</span><span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">Icyls</span><span class="p">,</span><span class="n">E</span><span class="p">,[</span><span class="n">Sci</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">print</span> <span class="s">&quot;Scaling: {0}, background {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Sc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c">#now for each sphere, calculate its volume fraction:</span>
        <span class="n">sR</span><span class="o">=</span><span class="n">size</span><span class="p">(</span><span class="n">R1rep</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Vf</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">=</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Vsa</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">Vpa</span><span class="o">*</span><span class="n">drhosqr</span><span class="p">)</span> <span class="c">#a set of intensities</span>
        <span class="n">Vft</span><span class="p">[</span><span class="n">nr</span><span class="p">]</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vf</span><span class="p">[:,</span><span class="n">nr</span><span class="p">])</span> <span class="c">#total volume squared</span>
        <span class="k">print</span> <span class="s">&quot;Calculating volfrac for this iteration: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Vft</span><span class="p">[</span><span class="n">nr</span><span class="p">])</span>
        <span class="c">#&lt;-- absolute intensity calculation</span>
        <span class="c">#Hr1=hist(R1rep[:,nr],Hx1,normed=False,weights=Vf[:,nr])</span>
        <span class="n">Hr1</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">R1rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">Hx1</span><span class="p">,</span><span class="n">density</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">Vf</span><span class="p">[:,</span><span class="n">nr</span><span class="p">])</span>
        <span class="c">#Hr2=hist(R2rep[:,nr],Hx2,normed=False,weights=Vf[:,nr])</span>
        <span class="n">Hr2</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">R2rep</span><span class="p">[:,</span><span class="n">nr</span><span class="p">],</span><span class="n">Hx2</span><span class="p">,</span><span class="n">density</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">Vf</span><span class="p">[:,</span><span class="n">nr</span><span class="p">])</span>
        <span class="c">#old, non-volume fraction: Hr=hist(Rrep[:,nr],Hx,normed=False,weights=1/Rrep[:,nr]**((3-Rpower)*2))</span>
        <span class="n">Hy1</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">=</span><span class="n">Hr1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Hy2</span><span class="p">[:,</span><span class="n">nr</span><span class="p">]</span><span class="o">=</span><span class="n">Hr2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">biglap</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c">#in minutes:</span>
        <span class="n">tottime</span><span class="o">=</span><span class="p">(</span><span class="n">biglap</span><span class="o">-</span><span class="n">bignow</span><span class="p">)</span><span class="o">/</span><span class="mf">60.</span>
        <span class="n">avetime</span><span class="o">=</span><span class="p">(</span><span class="n">tottime</span><span class="o">/</span><span class="p">(</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">remtime</span><span class="o">=</span><span class="p">(</span><span class="n">avetime</span><span class="o">*</span><span class="n">Nreps</span><span class="o">-</span><span class="n">tottime</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">*finished optimization number {0} of {1} </span><span class="se">\r\n\t</span><span class="s">*total elapsed time: {2} minutes </span><span class="se">\r\n\t</span><span class="s">*average time per optimization {3} minutes </span><span class="se">\r\n\t</span><span class="s">*total time remaining {4} minutes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">Nreps</span><span class="p">,</span><span class="n">tottime</span><span class="p">,</span><span class="n">avetime</span><span class="p">,</span><span class="n">remtime</span><span class="p">)</span>

    <span class="n">Imean</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Irep</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">Istd</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Irep</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">H1mid</span><span class="p">,</span><span class="n">H2mid</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">Histbins</span><span class="p">),</span><span class="n">zeros</span><span class="p">(</span><span class="n">Histbins</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bini</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Histbins</span><span class="p">):</span>
        <span class="n">H1mid</span><span class="p">[</span><span class="n">bini</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hx1</span><span class="p">[</span><span class="n">bini</span><span class="p">:</span><span class="n">bini</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">H2mid</span><span class="p">[</span><span class="n">bini</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hx2</span><span class="p">[</span><span class="n">bini</span><span class="p">:</span><span class="n">bini</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">H1mean</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hy1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">H2mean</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hy2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">H1std</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Hy1</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">H2std</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Hy2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">obs</span><span class="p">,</span><span class="n">qmo</span><span class="o">=</span><span class="n">observability</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">H1mid</span><span class="p">)</span>
    <span class="n">iobs</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">obs</span><span class="o">/</span><span class="n">obs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">H1mean</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c">#normalize inverse observability to amount in the last bin</span>


    <span class="c">#store in output dict</span>
    <span class="n">A</span><span class="o">=</span><span class="nb">dict</span><span class="p">()</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H1width&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">diff</span><span class="p">(</span><span class="n">Hx1</span><span class="p">)</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H1mid&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">H1mid</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H1mean&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">H1mean</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H1std&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">H1std</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;R1rep&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">R1rep</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;Hy1&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Hy1</span>

    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H2width&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">diff</span><span class="p">(</span><span class="n">Hx2</span><span class="p">)</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H2mid&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">H2mid</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H2mean&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">H2mean</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;H2std&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">H2std</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;R2rep&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">R2rep</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;Hy2&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Hy2</span>

    <span class="n">A</span><span class="p">[</span><span class="s">&#39;iobs&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">iobs</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;Imean&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Imean</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;Istd&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Istd</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;Vf&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Vf</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;Vft&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">Vft</span>
    <span class="n">A</span><span class="p">[</span><span class="s">&#39;q&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">q</span>

    <span class="n">A</span><span class="p">[</span><span class="s">&#39;Niter&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Niters</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">A</span>

<div class="viewcode-block" id="Icyl_InPlaneAverage_RandomSampling"><a class="viewcode-back" href="../code.html#McSAS.Icyl_InPlaneAverage_RandomSampling">[docs]</a><span class="k">def</span> <span class="nf">Icyl_InPlaneAverage_RandomSampling</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">psi</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mf">90.</span><span class="p">]),</span><span class="n">nsamples</span><span class="o">=</span><span class="s">&#39;auto&#39;</span><span class="p">,</span><span class="n">R1</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">R2</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    calculates the in-plane average of a shape (rotational average, but only rotated around the beam axis, perpendicular to the detector plane).</span>
<span class="sd">    This calculation works by uniform random number generation for q and psi, within the bounds dictated by the input. </span>
<span class="sd">    Set &quot;nsamples&quot; to a number of samples. &#39;auto&#39; sounds cool but has not been implemented yet. </span>
<span class="sd">    input &#39;q&#39; is supposed to be a vector of q values for which the intensity is requested</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Qs</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">q</span><span class="p">)),</span><span class="n">high</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">q</span><span class="p">)),</span><span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
    <span class="n">PSIs</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span><span class="n">high</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span><span class="n">size</span><span class="o">=</span><span class="n">nsamples</span><span class="p">)</span>
    <span class="n">Is</span><span class="o">=</span><span class="n">Icyl_2D</span><span class="p">(</span><span class="n">Qs</span><span class="p">,</span><span class="n">PSIs</span><span class="p">,</span><span class="n">R1</span><span class="p">,</span><span class="n">R2</span><span class="p">)</span>

    <span class="n">qbin</span><span class="p">,</span><span class="n">Ibin</span><span class="p">,</span><span class="n">SEbin</span><span class="o">=</span><span class="n">binning_weighted_1D</span><span class="p">(</span><span class="n">Qs</span><span class="p">,</span><span class="n">Is</span><span class="p">,</span><span class="n">Nbins</span><span class="o">=</span><span class="n">q</span><span class="p">,</span><span class="n">Stats</span><span class="o">=</span><span class="s">&#39;SE&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qbin</span><span class="p">,</span><span class="n">Ibin</span><span class="p">,</span><span class="n">SEbin</span>
    <span class="c">#this is not really an efficient way of doing it, requires many points</span>

</div>
<div class="viewcode-block" id="Integrate_Shape_as_Spherical_Isotropic"><a class="viewcode-back" href="../code.html#McSAS.Integrate_Shape_as_Spherical_Isotropic">[docs]</a><span class="k">def</span> <span class="nf">Integrate_Shape_as_Spherical_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">psirange</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">360.1</span><span class="p">]),</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span><span class="n">psidiv</span><span class="o">=</span><span class="mi">303</span><span class="p">,</span><span class="n">randfact</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a 1D intensity of a spherically isotropic shape. </span>
<span class="sd">    This is identical to a fully rotationally isotropic averaged shape, for radially isotropic shapes, use Integrate_Shape_as_Radial_Isotropic, which averages the shape around the axis perpendicular to the detector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d_to_r</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">180</span><span class="o">*</span><span class="n">pi</span>
    <span class="n">psi</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psirange</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psirange</span><span class="p">),</span><span class="n">psidiv</span><span class="p">)</span>
    <span class="n">Q</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">psi</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">PSI</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="n">psi</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">randfact</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">PSI</span><span class="o">=</span><span class="n">PSI</span><span class="o">+</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">diff</span><span class="p">(</span><span class="n">psirange</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">randfact</span><span class="o">*</span><span class="n">psidiv</span><span class="p">),</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">(</span><span class="n">PSI</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">Func</span><span class="o">==</span><span class="s">&#39;FF_ell_2D&#39;</span><span class="p">:</span>
        <span class="n">FFc</span><span class="o">=</span><span class="n">FF_ell_2D</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">PSI</span><span class="p">,</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">rot</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">FFcsqr</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">FFc</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">PSI</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#FFcsqr=1/diff(psirange)*numpy.trapz(FFc**2,axis=0,x=psi)</span>
        <span class="k">return</span> <span class="n">FFcsqr</span>
    <span class="k">elif</span> <span class="n">Func</span><span class="o">==</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">:</span>
        <span class="n">FFc</span><span class="o">=</span><span class="n">FF_cyl_2D</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">PSI</span><span class="p">,</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">rot</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">FFcsqr</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">FFc</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">PSI</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#FFcsqr=1/diff(psirange)*numpy.trapz(FFc**2,axis=0,x=psi)</span>
        <span class="k">return</span> <span class="n">FFcsqr</span>
</div>
<div class="viewcode-block" id="Integrate_Shape_as_Radial_Isotropic"><a class="viewcode-back" href="../code.html#McSAS.Integrate_Shape_as_Radial_Isotropic">[docs]</a><span class="k">def</span> <span class="nf">Integrate_Shape_as_Radial_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">psirange</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">360.1</span><span class="p">]),</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span><span class="n">psidiv</span><span class="o">=</span><span class="mi">303</span><span class="p">,</span><span class="n">randfact</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a 1D intensity of a radially isotropic shape. </span>
<span class="sd">    This is not identical to a fully rotationally isotropic shape, but merely isotropic as if the shape </span>
<span class="sd">    is rotated around the axis perpendicular to the detector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">psi</span><span class="o">=</span><span class="n">linspace</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">psirange</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">psirange</span><span class="p">),</span><span class="n">psidiv</span><span class="p">)</span>
    <span class="n">Q</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">psi</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">PSI</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">q</span><span class="o">+</span><span class="n">psi</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">randfact</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">PSI</span><span class="o">=</span><span class="n">PSI</span><span class="o">+</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">diff</span><span class="p">(</span><span class="n">psirange</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">randfact</span><span class="o">*</span><span class="n">psidiv</span><span class="p">),</span><span class="n">size</span><span class="o">=</span><span class="n">shape</span><span class="p">(</span><span class="n">PSI</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">Func</span><span class="o">==</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">:</span>
        <span class="n">FFc</span><span class="o">=</span><span class="n">FF_cyl_2D</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">PSI</span><span class="p">,</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">rot</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">FFcsqr</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">FFc</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c">#FFcsqr=1/diff(psirange)*numpy.trapz(FFc**2,axis=0,x=psi)</span>
        <span class="k">return</span> <span class="n">FFcsqr</span>
    <span class="k">elif</span> <span class="n">Func</span><span class="o">==</span><span class="s">&#39;Icyl_2D&#39;</span><span class="p">:</span>
        <span class="n">Ic</span><span class="o">=</span><span class="n">Icyl_2D</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">PSI</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">)</span>
        <span class="n">Ic</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ic</span>
</div>
<span class="k">def</span> <span class="nf">Icyl_2D</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">PSI</span><span class="p">,</span><span class="n">R1cyl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">R2cyl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
    <span class="c">#This function calculates the scattering intensity of a cylinder with radius R1cyl and height 2*R2cyl</span>
    <span class="k">if</span> <span class="n">parameters</span><span class="o">!=</span><span class="s">&#39;&#39;</span><span class="p">:</span>
        <span class="n">R1cyl</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">R2cyl</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rot</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">PSIr</span><span class="o">=</span><span class="p">(</span><span class="n">PSI</span><span class="o">-</span><span class="n">rot</span><span class="p">)</span><span class="o">/</span><span class="mi">180</span><span class="o">*</span><span class="n">pi</span>
    <span class="n">qRsina</span><span class="o">=</span><span class="n">Q</span><span class="o">*</span><span class="n">R1cyl</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">PSIr</span><span class="p">)</span>
    <span class="n">qLcosa</span><span class="o">=</span><span class="n">Q</span><span class="o">*</span><span class="n">R2cyl</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">PSIr</span><span class="p">)</span>
    <span class="n">FF</span><span class="o">=</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">j1</span><span class="p">(</span><span class="n">qRsina</span><span class="p">)</span><span class="o">/</span><span class="n">qRsina</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">qLcosa</span><span class="p">)</span><span class="o">/</span><span class="n">qLcosa</span> <span class="p">)</span>
    <span class="n">Vc</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1cyl</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">R2cyl</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">FF</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Vc</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span> <span class="nf">FF_ell_2D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">psi</span><span class="p">,</span><span class="n">R1</span><span class="p">,</span><span class="n">R2</span><span class="p">,</span><span class="n">rot</span><span class="p">):</span>
    <span class="c">#R1&lt;R2, prolate ellipsoid (cigar-shaped), R1&gt;R2, oblate ellipsoid (disk-shaped), rotation is offset from perfect orientation (psi-rot)</span>
    <span class="n">d_to_r</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">360</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="c">#degrees to radians, forget the dot and get yourself into a non-floating point mess, even though pi is floating point...</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">R1</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">sda</span><span class="o">=</span><span class="n">sin</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">)</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
        <span class="n">cda</span><span class="o">=</span><span class="n">cos</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">)</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
        <span class="n">r</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R1</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sda</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">R2</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cda</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">qr</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">r</span>
        <span class="n">Fell</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span><span class="o">-</span><span class="n">qr</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">qr</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">qr</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c">#calculate a series</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#one-dimensional q and psi, add another dimension</span>
            <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">psi</span><span class="o">=</span><span class="n">psi</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">Fell</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">size</span><span class="p">(</span><span class="n">R1</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1</span><span class="p">)):</span>
            <span class="n">sda</span><span class="o">=</span><span class="n">sin</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">[</span><span class="n">Ri</span><span class="p">])</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
            <span class="n">cda</span><span class="o">=</span><span class="n">cos</span><span class="p">((</span><span class="n">psi</span><span class="o">-</span><span class="n">rot</span><span class="p">[</span><span class="n">Ri</span><span class="p">])</span><span class="o">*</span><span class="n">d_to_r</span><span class="p">)</span>
            <span class="n">r</span><span class="o">=</span><span class="n">sqrt</span><span class="p">(</span><span class="n">R1</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sda</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">R2</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">cda</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">qr</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">r</span>
            <span class="n">Fell</span><span class="p">[:,:,</span><span class="n">Ri</span><span class="p">]</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">qr</span><span class="p">)</span><span class="o">-</span><span class="n">qr</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">qr</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">qr</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Fell</span> <span class="c">#this will be a three-dimensional result for ranges of Ri, and one- to two-dimensional for single radii sets</span>
    
<span class="k">def</span> <span class="nf">FF_cyl_2D</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">PSI</span><span class="p">,</span><span class="n">R1</span><span class="p">,</span><span class="n">R2</span><span class="p">,</span><span class="n">rot</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
    <span class="c">#Cylinder form factor, rotation is offset from perfect orientation (psi-rot)</span>
    <span class="n">d_to_r</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mi">180</span><span class="o">*</span><span class="n">pi</span> <span class="c">#degrees to radians, forget the dot and get yourself into a non-floating point mess, even though pi is floating point...</span>
    <span class="k">if</span> <span class="n">size</span><span class="p">(</span><span class="n">R1</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">PSIr</span><span class="o">=</span><span class="p">(</span><span class="n">PSI</span><span class="o">-</span><span class="n">rot</span><span class="p">)</span><span class="o">*</span><span class="n">d_to_r</span>
        <span class="n">qRsina</span><span class="o">=</span><span class="n">Q</span><span class="o">*</span><span class="n">R1</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">PSIr</span><span class="p">)</span>
        <span class="n">qLcosa</span><span class="o">=</span><span class="n">Q</span><span class="o">*</span><span class="n">R2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">PSIr</span><span class="p">)</span>
        <span class="n">Fcyl</span><span class="o">=</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">j1</span><span class="p">(</span><span class="n">qRsina</span><span class="p">)</span><span class="o">/</span><span class="n">qRsina</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">qLcosa</span><span class="p">)</span><span class="o">/</span><span class="n">qLcosa</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c">#calculate a series</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#one-dimensional q and psi, add another dimension</span>
            <span class="n">Q</span><span class="o">=</span><span class="n">Q</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">PSI</span><span class="o">=</span><span class="n">PSI</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">Fell</span><span class="o">=</span><span class="n">zeros</span><span class="p">([</span><span class="n">size</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">size</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">size</span><span class="p">(</span><span class="n">R1</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1</span><span class="p">)):</span>
            <span class="n">PSIr</span><span class="o">=</span><span class="p">(</span><span class="n">PSI</span><span class="o">-</span><span class="n">rot</span><span class="p">[</span><span class="n">Ri</span><span class="p">])</span><span class="o">*</span><span class="n">d_to_r</span>
            <span class="n">qRsina</span><span class="o">=</span><span class="n">Q</span><span class="o">*</span><span class="n">R1</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">PSIr</span><span class="p">)</span>
            <span class="n">qLcosa</span><span class="o">=</span><span class="n">Q</span><span class="o">*</span><span class="n">R2</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">PSIr</span><span class="p">)</span>
            <span class="n">Fcyl</span><span class="p">[:,:,</span><span class="n">Ri</span><span class="p">]</span><span class="o">=</span><span class="p">(</span> <span class="mi">2</span><span class="o">*</span><span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">j1</span><span class="p">(</span><span class="n">qRsina</span><span class="p">)</span><span class="o">/</span><span class="n">qRsina</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">qLcosa</span><span class="p">)</span><span class="o">/</span><span class="n">qLcosa</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">Fcyl</span> <span class="c">#this will be a three-dimensional result for ranges of Ri, and one- to two-dimensional for single radii sets</span>

<span class="c">#dead code, may be deleted.</span>
    
<span class="c">#useful, but not in this set of functions:</span>

<span class="k">def</span> <span class="nf">Icyl_1D_SphericallyIsotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">R1set</span><span class="o">=</span><span class="p">[],</span><span class="n">R2set</span><span class="o">=</span><span class="p">[],</span><span class="n">OBounds</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.01</span><span class="p">]),</span><span class="n">Rpfactor</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">R2IsAspect</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c">#generates intensity of a set of randomly oriented cylinders with radius R1set and length R2set*2.</span>
        
    <span class="c">#intialise variables</span>
    <span class="n">FFsqrset</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Vset</span><span class="o">=</span><span class="p">[]</span>
    
    <span class="n">Ncyl</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">R1set</span><span class="p">)</span>
    <span class="c">#generate set of spheres</span>
    <span class="n">Oset</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">OBounds</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">OBounds</span><span class="p">),</span><span class="n">Ncyl</span><span class="p">)</span>

    <span class="c">#calculate their form factors</span>
    <span class="c">#FFset=FF_sph_1D(q,Rset)</span>
    <span class="n">FFsqrset</span><span class="o">=</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">),</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
    <span class="k">print</span> <span class="s">&quot;Generating initial set of cylinders...&quot;</span>
    <span class="n">now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
            <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Spherical_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">R2set</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">*</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Oset</span><span class="p">[</span><span class="n">Ri</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Spherical_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_cyl_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">R2set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Oset</span><span class="p">[</span><span class="n">Ri</span><span class="p">]]))</span>
    <span class="k">print</span> <span class="s">&quot;average time (s) per cylinder: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">now</span><span class="p">)</span><span class="o">/</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
        <span class="n">Vset</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1set</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">R2set</span><span class="o">*</span><span class="n">R1set</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Vset</span><span class="o">=</span><span class="n">pi</span><span class="o">*</span><span class="n">R1set</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">R2set</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
    <span class="c">#calculate the intensities</span>
    <span class="n">Iset</span><span class="o">=</span><span class="n">FFsqrset</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFsqrset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
    <span class="n">It</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c">#the total intensity</span>
    <span class="k">return</span> <span class="n">It</span>

<span class="k">def</span> <span class="nf">Iell_1D_SphericallyIsotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">R1set</span><span class="o">=</span><span class="p">[],</span><span class="n">R2set</span><span class="o">=</span><span class="p">[],</span><span class="n">OBounds</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.01</span><span class="p">]),</span><span class="n">Rpfactor</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span><span class="n">R2IsAspect</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="c">#generates intensity of a set of randomly oriented cylinders with radius R1set and length R2set*2.</span>
        
    <span class="c">#intialise variables</span>
    <span class="n">FFsqrset</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Vset</span><span class="o">=</span><span class="p">[]</span>
    
    <span class="n">Nell</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">R1set</span><span class="p">)</span>
    <span class="c">#generate set of spheres</span>
    <span class="n">Oset</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">OBounds</span><span class="p">),</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">OBounds</span><span class="p">),</span><span class="n">Nell</span><span class="p">)</span>

    <span class="c">#calculate their form factors</span>
    <span class="c">#FFset=FF_sph_1D(q,Rset)</span>
    <span class="n">FFsqrset</span><span class="o">=</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">),</span><span class="n">size</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span>
    <span class="k">print</span> <span class="s">&quot;Generating initial set of ellipsoids...&quot;</span>
    <span class="n">now</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">Ri</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
            <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Spherical_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_ell_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">R2set</span><span class="p">[</span><span class="n">Ri</span><span class="p">]</span><span class="o">*</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Oset</span><span class="p">[</span><span class="n">Ri</span><span class="p">]]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FFsqrset</span><span class="p">[</span><span class="n">Ri</span><span class="p">,:]</span><span class="o">=</span><span class="n">Integrate_Shape_as_Spherical_Isotropic</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Func</span><span class="o">=</span><span class="s">&#39;FF_ell_2D&#39;</span><span class="p">,</span><span class="n">parameters</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">R1set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">R2set</span><span class="p">[</span><span class="n">Ri</span><span class="p">],</span><span class="n">Oset</span><span class="p">[</span><span class="n">Ri</span><span class="p">]]))</span>
    <span class="k">print</span> <span class="s">&quot;average time (s) per cylinder: {0}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">now</span><span class="p">)</span><span class="o">/</span><span class="n">size</span><span class="p">(</span><span class="n">R1set</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">R2IsAspect</span><span class="p">:</span>
        <span class="n">Vset</span><span class="o">=</span><span class="mf">4.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">R1set</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">R2set</span><span class="o">*</span><span class="n">R1set</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Vset</span><span class="o">=</span><span class="mf">4.</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">R1set</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span><span class="o">*</span><span class="n">R2set</span><span class="o">**</span><span class="p">(</span><span class="n">Rpfactor</span><span class="p">)</span>
    <span class="c">#calculate the intensities</span>
    <span class="n">Iset</span><span class="o">=</span><span class="n">FFsqrset</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFsqrset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
    <span class="n">Vst</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c">#total volume squared</span>
    <span class="n">It</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c">#the total intensity</span>
    <span class="k">return</span> <span class="n">It</span>

<span class="k">def</span> <span class="nf">observability</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Rset</span><span class="p">,</span><span class="n">I</span><span class="o">=</span><span class="p">[],</span><span class="n">E</span><span class="o">=</span><span class="p">[],</span><span class="n">Rpfactor</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="c">#observability calculation for a series of spheres, over a range of q. Additional intensity and errors may be supplied for error-weighted observability. Intensity is used for determining the intesity scaling and background levels.</span>
    <span class="n">FFset</span><span class="o">=</span><span class="n">FF_sph_1D</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">Rset</span><span class="p">)</span>
    <span class="n">Vset</span><span class="o">=</span><span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="mi">3</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">Rset</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">Rpfactor</span><span class="p">)</span>
    <span class="c">#calculate the intensities</span>
    <span class="n">Iset</span><span class="o">=</span><span class="n">FFset</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Vset</span><span class="p">[:,</span><span class="n">newaxis</span><span class="p">]</span><span class="o">+</span><span class="mi">0</span><span class="o">*</span><span class="n">FFset</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="c">#a set of intensities</span>
    <span class="n">Vst</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Vset</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c">#total volume squared</span>
    <span class="n">It</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c">#the total intensity</span>
    <span class="c">#optimize the intensities and calculate convergence criterium</span>
    <span class="n">ov</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Rset</span><span class="p">))</span>
    <span class="n">qm</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Rset</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">==</span><span class="n">size</span><span class="p">(</span><span class="n">E</span><span class="p">))</span><span class="o">&amp;</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">Sc</span><span class="p">,</span><span class="n">Conval1</span><span class="o">=</span><span class="n">Iopt_v1</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">It</span><span class="o">/</span><span class="n">Vst</span><span class="p">,</span><span class="n">E</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="c">#V1 is more robust w.r.t. a poor initial guess</span>
        <span class="n">Sc</span><span class="p">,</span><span class="n">Conval</span><span class="o">=</span><span class="n">Iopt</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">It</span><span class="o">/</span><span class="n">Vst</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">Sc</span><span class="p">)</span> <span class="c">#reoptimize with V2, there might be a slight discrepancy in the residual definitions of V1 and V2 which would prevent optimization.</span>
        <span class="k">print</span> <span class="s">&quot;Conval V1&quot;</span><span class="p">,</span><span class="n">Conval1</span>
        <span class="k">print</span> <span class="s">&quot;Conval V2&quot;</span><span class="p">,</span><span class="n">Conval</span>
        <span class="k">print</span> <span class="n">Sc</span>
        <span class="k">for</span> <span class="n">isi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">ov</span><span class="p">[</span><span class="n">isi</span><span class="p">]</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Iset</span><span class="p">[</span><span class="n">isi</span><span class="p">,:]</span><span class="o">/</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">E</span><span class="p">))</span>
            <span class="c">#ov[isi]=numpy.max(Iset[isi,:]/(size(I)*Sc[0]*E))</span>
            <span class="n">qm</span><span class="p">[</span><span class="n">isi</span><span class="p">]</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">Iset</span><span class="p">[</span><span class="n">isi</span><span class="p">,:]</span><span class="o">/</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">*</span><span class="n">E</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">isi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">Iset</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
            <span class="n">ov</span><span class="p">[</span><span class="n">isi</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Iset</span><span class="p">[</span><span class="n">isi</span><span class="p">,:]</span><span class="o">/</span><span class="n">It</span><span class="p">)</span>
            <span class="n">qm</span><span class="p">[</span><span class="n">isi</span><span class="p">]</span><span class="o">=</span><span class="n">q</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Iset</span><span class="p">[</span><span class="n">isi</span><span class="p">,:]</span><span class="o">/</span><span class="n">It</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">ov</span><span class="p">,</span><span class="n">qm</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">McSAS v1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Brian R. Pauw.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>