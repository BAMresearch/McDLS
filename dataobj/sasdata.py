# -*- coding: utf-8 -*-
# dataobj/sasdata.py

"""
Represents data associated with a measurement by small angle scattering (SAS).
Some examples and tests.

>>> import numpy
>>> testdata = numpy.random.rand(4,4)
>>> testtitle = "some title"
>>> from sasdata import SASData

Testing
>>> first = SASData(testtitle, testdata)
>>> first.title == testtitle
True
>>> numpy.all(first.rawArray == testdata)
True
"""

from __future__ import absolute_import # PEP328
import logging
import numpy as np # For arrays
from utils import classproperty
from utils.units import Length, ScatteringVector, ScatteringIntensity, Angle
from dataobj import DataObj, SASConfig, DataVector
from models import SASModel

class SASData(DataObj):
    """Represents one set of data from a unique source (a file, for example).
    """
    _sizeEst = None
    _shannonChannelEst = None
    _eMin = 0.01 # minimum possible error (1%)
    _uncertainty = None
    _rUnit = None # defines units for r used in sizeest
    _pClipRange = [-np.inf, np.inf] # psi clip range for this dataset
    _validIndices = None # valid indices generated by the prepareClipMask function

    # define DataObj interface

    @property
    def x0(self):
        return self.qi

    @property
    def x1(self):
        return self.pi

    @property
    def f(self):
        return self.ii

    @property
    def fu(self):
        return self.ui

    # legacy SASData properties

    @classproperty
    @classmethod
    def sourceName(cls):
        return "Small Angle Scattering"

    # scattering vector

    @property
    def q(self):
        """Q-Vector at which the intensities are measured."""
        return self.qi.sanitized

    @property
    def qOrigin(self):
        return self.qi.siData

    @property
    def qUnit(self):
        return self.qi.unit

    @property
    def qLimsString(self):
        return self.qi.limsString

    # uncertainty on the intensities from data file

    @property
    def e(self):
        """Uncertainty or Error of the intensity at q loaded from file."""
        return self.ei.sanitized

    @property
    def eOrigin(self):
        return self.ei.siData

    # sanitized uncertainty on the intensities

    @property
    def u(self):
        """Corrected uncertainty or error of the intensity at q."""
        return self.ui.sanitized

    @property
    def uOrigin(self):
        return self.ui.siData

    # psi scattering vector for 2D data

    @property
    def p(self): # famous rapper of the Osdorp Posse!
        """Psi-Vector."""
        return self.rawArray[:, 3]

    @property
    def pOrigin(self):
        return self.pUnit.toSi(self.rawArray[:, 3])

    @property
    def pUnit(self):
        return self.config.pUnit

    @property
    def pMin(self):
        """Returns minimum psi from data or psiClipRange, whichever is larger."""
        if self.is2d:
            return np.maximum(self.pClipRange[0], 
                    self.pOrigin.min())
        else:
            return self.pClipRange[0]

    @pMin.setter
    def pMin(self, newParam):
        """Value in cliprange will not exceed available psi."""
        if self.is2d:
            self._pClipRange[0] = np.maximum(
                newParam, self.pOrigin.min())
        else:
            self._pClipRange[0] = self.pUnit.toSi(newParam)
        self._prepareValidIndices()

    @property
    def pMax(self):
        if self.is2d:
            return np.minimum(self.pClipRange[1], 
                    self.pOrigin.max())
        else:
            return self.pClipRange[1]

    @pMax.setter
    def pMax(self, newParam):
        """Value in cliprange will not exceed available psi."""
        if self.is2d:
            self._pClipRange[1] = np.minimum(
                newParam, self.pOrigin.max())
        else:
            self._pClipRange[1] = self.pUnit.toSi(newParam)
        self._prepareValidIndices()

    @property
    def pClipRange(self):
        return self._pClipRange

    @pClipRange.setter
    def pClipRange(self, newParam):
        if not (np.size(newParam) == 2):
            logging.error('pClipRange must be supplied with two-element vector')
        else:
            self.pMin(np.min(newParam))
            self.pMax(np.min(newParam))

    @property
    def pLimsString(self):
        return u"{0:.3g} ≤ psi ({psiMagnitudeName}) ≤ {1:.3g}".format(
                self.pUnit.toDisplay(self.pMin),
                self.pUnit.toDisplay(self.pMax),
                pMagnitudeName = self.pUnit.displayMagnitudeName)

    # general information on this data set

    @property
    def count(self):
        return len(self.q)

    @property
    def validIndices(self): # global valid indices
        if self._validIndices is not None:
            return self._validIndices
        else:
            # valid indices not set yet
            self._prepareValidIndices()
            return self._validIndices

    @property
    def is2d(self):
        """Returns true if this dataset contains two-dimensional data with
        psi information available."""
        return self.rawArray.shape[1] > 3 # psi column is present

    @property
    def hasError(self):
        """Returns True if this data set has an error bar for its
        intensities."""
        return self.rawArray.shape[1] > 2

    # general info texts for the UI

    @property
    def dataContent(self):
        """shows the content of the loaded data: Q, I, IErr, etc"""
        content = []
        if self.x0 is not None:
            content.append(self.x0.name)
        if self.f is not None:
            content.append(self.f.name)
        if self.fu is not None:
            content.append(self.fu.name)
        if self.is2d:
            content.append('Psi')
        return ", ".join(content)

    @classproperty
    @classmethod
    def displayDataDescr(cls):
        return ("Filename ", "Data points ", "Data content ", 
                "Q limits ", "Est. sphere size ", "Recommended number of bins ")

    @classproperty
    @classmethod
    def displayData(cls):
        return ("title", "count", "dataContent", 
                "qLimsString", "sphericalSizeEstText", "shannonChannelEstText")

    def sphericalSizeEst(self):
        return self._sizeEst

    @property
    def rUnit(self):
        return self._rUnit

    @property
    def sphericalSizeEstText(self):
        return u"{0:.3g} ≤ R ({rUnitName}) ≤ {1:.3g} ".format(
                *self.rUnit.toDisplay(self.sphericalSizeEst()),
                rUnitName = self.rUnit.displayMagnitudeName)

    def shannonChannelEst(self):
        return int(self._shannonChannelEst)

    @property
    def shannonChannelEstText(self):
        return u"≤ {0:2d} bins ".format(self.shannonChannelEst())

    def __init__(self, **kwargs):
        super(SASData, self).__init__(**kwargs)
        
        # process rawArray for new DataVector instances:
        rawArray = kwargs.pop('rawArray', None)
        if rawArray is None:
            logging.error('SASData must be called with a rawArray provided')

        self.qi = DataVector(u'q', rawArray[:, 0], 
                unit = ScatteringVector(u"nm⁻¹"))
        self.ii = DataVector(u'I', rawArray[:, 1], 
                unit = ScatteringIntensity(u"(m sr)⁻¹"))
        self.ei = DataVector(u'∆I', rawArray[:, 2],
                unit = self.ii.unit)
        self.ui = DataVector(u'σI', rawArray[:, -1], # we should use self.ei.copy
                unit = self.ii.unit, editable = True)
        self.qi.limit = [self.qi.sanitized.min(), self.qi.sanitized.max()]
        logging.info(self.qi.limsString)
        if rawArray.shape[1] > 3: # psi column is present
            self.pi = DataVector(u'ψ', rawArray[:, 3], unit = Angle(u"°"))
        else:
            self.pi = None

        #set unit definitions for display and internal units
        self._rUnit = Length(u"nm")
        # init config as early as possible to get properties ready which
        # depend on it (qlow/qhigh?)
        self.setConfig(self.configType())

    def setConfig(self, config):
        if not super(SASData, self).setConfig(config):
            return # no update, nothing todo
        # call setLimit() on change of x-limits in config
        self.config.register("xlimits", self._onQLimitUpdate)
        self.config.register("xlimits", self._onQLimitUpdate)
        self._onQLimitUpdate((self.config.xLow(), self.config.xHigh()))
        self.config.register("fMasks", self._prepareValidIndices)
        self.config.register("eMin", self._prepareUncertainty)
        # prepare
        self.locs = self.config.prepareSmearing(self.qi.siData)

    # short-hand for three different updates
    def _onQLimitUpdate(self, newLimit):
        """Bulk update of all parts directly dependent on Q-min/max."""
        self.qi.setLimit(newLimit)
        self._shannonChannelEst = self.qi.limit[1] / self.qi.limit[0]
        self._prepareValidIndices()

    @property
    def configType(self):
        return SASConfig

    @property
    def modelType(self):
        return SASModel


    def _prepareUncertainty(self, *dummy):
        """Modifies the uncertainty of the whole range of measured data to be
        above a previously set minimum threshold *eMin*."""
        self.ui.siData = self.config.eMin() * self.f.siData
        minUncertaintyPercent = self.config.eMin() * 100.
        if not self.hasError:
            logging.warning("No error column provided! Using {}% of intensity."
                            .format(minUncertaintyPercent))
        else:
            count = sum(self.ui.siData > self.ei.siData)
            if count > 0:
                logging.warning("Minimum uncertainty ({}% of intensity) set "
                                "for {} datapoints.".format(
                                minUncertaintyPercent, count))
            self.ui.siData = np.maximum(self.ui.siData, self.ei.siData)
        # reset invalid uncertainties to np.inf
        invInd = (True - np.isfinite(self.ui.siData))
        self.ui.siData[invInd] = np.inf

    def _prepareValidIndices(self, *dummy):
        """
        If q and/or psi limits are supplied in the dataset,
        prepares a clipmask for the full dataset
        """
        # init indices: index array is more flexible than boolean masks
        mask = np.isfinite(self.ii.siData)

        # Optional masking of negative intensity
        if self.config.fMaskZero():
            # FIXME: compare with machine precision (EPS)?
            mask &= (self.ii.siData != 0.0)
        if self.config.fMaskNeg():
            mask &= (self.ii.siData > 0.0)

#        from utils.devtools import DBG
#        DBG('size mask: {}, qMin: {}, qMax: {}'
#            .format(mask.sum(), self.config.xLow(), self.config.xHigh()))
        # clip to q bounds
        mask &= (self.qi.siData >= self.config.xLow())
        mask &= (self.qi.siData <= self.config.xHigh())
        # clip to psi bounds
        if self.is2d:
            raise NotImplementedError
            mask &= (self.pOrigin > self.pMin)
            mask &= (self.pOrigin <= self.pMax)
        # store
        self._validIndices = np.argwhere(mask)[:,0]
        # a quick, temporary implementation to pass on all valid indices to the parameters:
        self.f.validIndices = self._validIndices
        self.fu.validIndices = self._validIndices
        self.x0.validIndices = self._validIndices
        self._prepareSizeEst() # recalculate based on limits. 

    def _prepareSizeEst(self):
        self._sizeEst = np.pi / np.array([self.qi.limit[1],
                                          abs(self.qi.limit[0]) ])

if __name__ == "__main__":
    import doctest
    doctest.testmod()

# vim: set ts=4 sts=4 sw=4 tw=0:
