# -*- coding: utf-8 -*-
# mcsas/sasdata.py

"""
Represents data associated with a measurement by small angle scattering (SAS).
Some examples and tests.

>>> import numpy
>>> testdata = numpy.random.rand(4,4)
>>> testtitle = "some title"
>>> from sasdata import SASData

Testing
>>> first = SASData(testtitle, testdata)
>>> first.title == testtitle
True
>>> numpy.all(first.rawArray == testdata)
True
"""

from __future__ import absolute_import # PEP328
import os # Miscellaneous operating system interfaces
import logging
import numpy as np # For arrays
from datafile import loadfile
from utils import isList, classproperty
from gui.utils import processEventLoop
from utils.units import Length, ScatteringVector, ScatteringIntensity, Angle

# related to the class below
from abc import ABCMeta, abstractproperty
from bases.dataset import DataSet, DisplayMixin
class ScatteringData(DataSet, DisplayMixin):
    """General container for data loaded from file. It offers specialised
    methods to derive information from the provided data.
    """
    __metaclass__ = ABCMeta
    _filename = None

    @property
    def filename(self):
        return self._filename

    def setFilename(self, fn):
        """Stores the absolute path to this data file.
        Should be reviewed when data sets can be created from several files."""
        if fn is None or not os.path.isfile(fn):
            return
        self._filename = os.path.abspath(fn)

    def __init__(self, **kwargs):
        super(ScatteringData, self).__init__(**kwargs)

    def __eq__(self, other):
        return (np.all(self.rawArray == other.rawArray)
                and self.title == other.title
                and self.filename == other.filename)

    def __neq__(self, other):
        return not self.__eq__(other)

def loaddatafile(filename):
    datafile = loadfile(filename)

class SASData(ScatteringData):
    """Represents one set of data from a unique source (a file, for example).
    """
    _sizeEst = None
    _shannonChannelEst = None
    _eMin = 0.01 # minimum possible error (1%)
    _uncertainty = None
    _qUnit = None # will be instance of SASUnit, defines units
    _pUnit = None # will be instance of SASUnit, defines units
    _iUnit = None # will be instance of SASUnit, defines units
    _rUnit = None # defines units for r used in sizeest
    _qClipRange = [-np.inf, np.inf] # Q clip range for this dataset
    _pClipRange = [-np.inf, np.inf] # psi clip range for this dataset
    _maskZeroInt = False # mask zero intensity values (updated by mcsasparam)
    _maskNegativeInt = False # mask negative intensity values (updated by mcsasparam)
    _validIndices = None # valid indices generated by the prepareClipMask function

    @classmethod
    def load(cls, filename):
        """Factory method for creating SASData objects from file."""
        sasfile = loadfile(filename)
        sasData = cls(title = sasfile.name, rawArray = sasfile.rawArray)
        sasData.setFilename(sasfile.filename)
        return sasData

    # intensity

    @property
    def i(self):
        """Measured intensity at q."""
        return self.iOrigin.copy()[self.validIndices]

    @property
    def iOrigin(self):
        return self.iUnit.toSi(self.rawArray[:, 1])

    @property
    def iUnit(self):
        return self._iUnit

    # scattering vector

    @property
    def q(self):
        """Q-Vector at which the intensities are measured."""
        return self.qOrigin.copy()[self.validIndices]

    @property
    def qOrigin(self):
        return self.qUnit.toSi(self.rawArray[:, 0])

    @property
    def qUnit(self):
        return self._qUnit

    @property
    def qMin(self):
        """Returns minimum q from data or qClipRange, whichever is larger."""
        return np.maximum(self.qClipRange[0], 
                self.qOrigin.min())

    @qMin.setter
    def qMin(self, newParam):
        """Value in cliprange will not exceed available q."""
        self._qClipRange[0] = np.maximum(newParam, 
                self.qOrigin.min())
        self._prepareValidIndices()

    @property
    def qMax(self):
        return np.minimum(self.qClipRange[1], 
                self.qOrigin.max())

    @qMax.setter
    def qMax(self, newParam):
        """Value in cliprange will not exceed available q."""
        self._qClipRange[1] = np.minimum(newParam, 
                self.qOrigin.max())
        self._prepareValidIndices()

    @property
    def qClipRange(self):
        return self._qClipRange

    @qClipRange.setter
    def qClipRange(self, newParam):
        if not (np.size(newParam) == 2):
            logging.error('qClipRange must be supplied with two-element vector')
        else:
            self.qMin(np.min(newParam))
            self.qMax(np.min(newParam))

    @property
    def qLimsString(self):
        return u"{0:.3g} ≤ Q ({qMagnitudeName}) ≤ {1:.3g}".format(
                self.qUnit.toDisplay(self.qMin),
                self.qUnit.toDisplay(self.qMax),
                qMagnitudeName = self.qUnit.displayMagnitudeName)

    # uncertainty on the intensities from data file

    @property
    def e(self):
        """Uncertainty or Error of the intensity at q loaded from file."""
        return self.eOrigin.copy()[self.validIndices]

    @property
    def eOrigin(self):
        return self.iUnit.toSi(self.rawArray[:, 2])

    @property
    def eMin(self):
        return self._eMin

    @eMin.setter
    def eMin(self, value):
        value = float(value) 
        assert((value > 0.) and (value < 1.))
        self._eMin = value
        #update uncertainty in case eMin was adjusted
        self._prepareUncertainty() 
        self._prepareValidIndices()

    # sanitized uncertainty on the intensities

    @property
    def u(self):
        """Corrected uncertainty or error of the intensity at q."""
        return self.uOrigin.copy()[self.validIndices]

    @property
    def uOrigin(self):
        return self._uncertainty

    # psi scattering vector for 2D data

    @property
    def p(self):
        """Psi-Vector."""
        return self.rawArray[:, 3]

    @property
    def pUnit(self):
        return self._pUnit

    @property
    def pMin(self):
        """Returns minimum psi from data or psiClipRange, whichever is larger."""
        if self.is2d:
            return np.maximum(self.pClipRange[0], 
                    self.pOrigin.min())
        else:
            return self.pClipRange[0]

    @pMin.setter
    def pMin(self, newParam):
        """Value in cliprange will not exceed available psi."""
        if self.is2d:
            self._pClipRange[0] = np.maximum(newParam, 
                    self.pOrigin.min())
        else:
            self._pClipRange[0] = newParam
        self._prepareValidIndices()

    @property
    def pMax(self):
        if self.is2d:
            return np.minimum(self.pClipRange[1], 
                    self.pOrigin.max())
        else:
            return self.pClipRange[1]

    @pMax.setter
    def pMax(self, newParam):
        """Value in cliprange will not exceed available psi."""
        if self.is2d:
            self._pClipRange[1] = np.minimum(newParam, 
                    self.pOrigin.max())
        else:
            self._pClipRange[1] = newParam
        self._prepareValidIndices()

    @property
    def pClipRange(self):
        return self._pClipRange

    @pClipRange.setter
    def pClipRange(self, newParam):
        if not (np.size(newParam) == 2):
            logging.error('pClipRange must be supplied with two-element vector')
        else:
            self.pMin(np.min(newParam))
            self.pMax(np.min(newParam))

    @property
    def pLimsString(self):
        return u"{0:.3g} ≤ psi ({psiMagnitudeName}) ≤ {1:.3g}".format(
                self.pUnit.toDisplay(self.pMin),
                self.pUnit.toDisplay(self.pMax),
                pMagnitudeName = self.pUnit.displayMagnitudeName)

    # general information on this data set

    @property
    def count(self):
        return len(self.q)

    @property
    def validIndices(self):
        if self._validIndices is not None:
            return self._validIndices
        else:
            # valid indices not set yet
            self._prepareValidIndices()
            return self._validIndices

    @property
    def is2d(self):
        """Returns true if this dataset contains two-dimensional data with
        psi information available."""
        return self.rawArray.shape[1] > 3 # psi column is present

    @property
    def hasError(self):
        """Returns True if this data set has an error bar for its
        intensities."""
        return self.rawArray.shape[1] > 2

    # general info texts for the UI

    @property
    def dataContent(self):
        """shows the content of the loaded data: Q, I, IErr, etc"""
        content = []
        if self.q is not None:
            content.append('Q')
        if self.i is not None:
            content.append('I')
        if self.hasError:
            content.append('IErr')
        if self.is2d:
            content.append('Psi')
        return ", ".join(content)

    @classproperty
    @classmethod
    def displayDataDescr(cls):
        return ("Filename ", "Data points ", "Data content ", 
                "Q limits ", "Est. sphere size ", "Recommended number of bins ")

    @classproperty
    @classmethod
    def displayData(cls):
        return ("title", "count", "dataContent", 
                "qLimsString", "sphericalSizeEstText", "shannonChannelEstText")

    def sphericalSizeEst(self):
        return self._sizeEst

    @property
    def rUnit(self):
        return self._rUnit

    @property
    def sphericalSizeEstText(self):
        return u"{0:.3g} ≤ R ({rUnitName}) ≤ {1:.3g} ".format(
                *self.rUnit.toDisplay(self.sphericalSizeEst()),
                rUnitName = self.rUnit.displayMagnitudeName)

    def shannonChannelEst(self):
        return int(self._shannonChannelEst)

    @property
    def shannonChannelEstText(self):
        return u"≤ {0:2d} bins ".format(self.shannonChannelEst())

    # masking helpers for sanitizing input data

    @property
    def maskZeroInt(self):
        return bool(self._maskZeroInt)

    @maskZeroInt.setter
    def maskZeroInt(self, value):
        self._maskZeroInt = bool(value)
        self._prepareValidIndices()

    @property
    def maskNegativeInt(self):
        return bool(self._maskNegativeInt)

    @maskNegativeInt.setter
    def maskNegativeInt(self, value):
        self._maskNegativeInt = bool(value)
        self._prepareValidIndices()

    def __init__(self, **kwargs):
        super(SASData, self).__init__(**kwargs)
        #set unit definitions for display and internal units
        self._iUnit = ScatteringIntensity(u"(m sr)⁻¹")
        self._qUnit = ScatteringVector(u"nm⁻¹")
        self._pUnit = Angle(u"˚")
        self._rUnit = Length(u"nm")

        self._prepareValidIndices()
        self._sizeEst = np.pi / np.array([self.q.max(),
                                          abs(self.q.min()) ])
        self._shannonChannelEst = self.q.max() / self.q.min()
        self._prepareUncertainty()

    def _prepareUncertainty(self):
        self._uncertainty = self.eMin * self.i
        minUncertaintyPercent = self.eMin * 100.
        if not self.hasError:
            logging.warning("No error column provided! Using {}% of intensity."
                            .format(minUncertaintyPercent))
        else:
            count = sum(self._uncertainty > self.e)
            if count > 0:
                logging.warning("Minimum uncertainty ({}% of intensity) set "
                                "for {} datapoints.".format(
                                minUncertaintyPercent, count))
            self._uncertainty = np.maximum(self._uncertainty, self.e)

    def _prepareValidIndices(self):
        """
        If q and/or psi limits are supplied in the dataset,
        prepares a clipmask for the full dataset
        """
        # init indices: index array is more flexible than boolean masks
        validIndices = np.where(np.isfinite(self.qOrigin))[0]
        def cutIndices(validIndices, mask):
            validIndices = validIndices[mask]

        # Optional masking of negative intensity
        if self.maskZeroInt:
            # FIXME: compare with machine precision (EPS)?
            cutIndices(validIndices,
                    self.iOrigin[validIndices] == 0.0)
        if self.maskNegativeInt:
            cutIndices(validIndices,
                    self.iOrigin[validIndices] > 0.0)
        # clip to q bounds
        cutIndices(validIndices,
                self.qOrigin[validIndices] >= self.qMin)
        cutIndices(validIndices,
                self.qOrigin[validIndices] <= self.qMax)
        # clip to psi bounds
        if self.is2d:
            cutIndices(validIndices,
                    self.pOrigin[validIndices] > self.pMin)
            cutIndices(validIndices,
                    self.pOrigin[validIndices] <= self.pMax)

        #store:
        self._validIndices = validIndices

if __name__ == "__main__":
    import doctest
    doctest.testmod()

# vim: set ts=4 sts=4 sw=4 tw=0:
