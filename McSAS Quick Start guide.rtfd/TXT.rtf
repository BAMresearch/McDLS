{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\froman\fcharset0 Palatino-Roman;\f1\fmodern\fcharset0 CourierNewPSMT;\f2\fswiss\fcharset0 Helvetica;
}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10760\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\b\fs58 \cf0 McSAS Quick Usage guide.\

\b0\fs24 \

\i\fs32 Introduction.\

\i0\fs24 \
This guide is intended as an aid to getting the first fits using McSAS. For comprehensive details of what goes on under the hood, please refer as a baseline to the paper. Additionally, the code is open source, and provides the best "documentation" of what actually takes place.\
\
When publishing results using this code, please be so kind as to cite the paper as:\
Pauw, B. R., Pedersen, J. S., Tardif, S., Takata, M. and Iversen, B. B., J. Appl. Cryst. 
\b 46
\b0  (2013), 
\i in press
\i0 \
\
This document assumes a modicum of proficiency with the Python language, to a level sufficient for  reading in a dataset.\
\

\i\fs32 Changes since the paper include:\

\i0\fs24 \
A replacement of p_c by Rpfactor, where Rpfactor=1-(p_c/6). Setting Rpfactor to 0.5 will work in most cases.\
\

\i\fs32 Scope of the code capabilities\

\i0\fs24 \
The McSAS code at the moment can:\
1. Fit supplied data to a set of polydisperse spheres\
2. Plot the data and fit alongside the distribution\
3. Rebin the result \
4. Export the result to a semilcolon-delimited CSV file. \
\
These aspects will be discussed in that order in this document.\
\

\i\fs32 -1. Loading the Python functions\

\i0\fs24 Assuming you have a suitable Python prompt, such as provided by iPython from the Enthought Python Distribution, you can load the McSAS functions using:\
-->\

\f1 execfile('McSAS.py')\

\f0 <--
\i\fs32 \
\
0. Loading test data\
\

\i0\fs24 A set of test data has been included in the directory, with concatenated data from two measurements (measured over different angular ranges). The sample is a porous organic material. The uncertainty has been estimated as outlined in the paper. \
The dataset can be loaded using the pickle functions provided in McSAS:\
-->\

\f1 QIE=pickle_load('test_data.pydat')\
q=QIE[0,:]\
I=QIE[1,:]\
E=QIE[2,:]
\f0 \
<--
\i\fs32 \
\
1. Fitting a dataset\

\i0\fs24 \
It is assumed that a dataset has been loaded into Python, and that the 1D q-vector, accompanying 1D intensity and uncertainty ("error", or standard deviation) is available as "q", "I", and "E", respectively. \
For consistency throughout the calculation and its parameters, all length units are given in meters, which is particularly important if the measurement is done in absolute units, and retrieval of the actual volume fraction is required. \
\
This implies that "q" must have the units of [1/m] and "I" and "E" must have the units of [1/(m sr)]. Additionally, the optional size bounds are to be given in meters, and the scattering contrast, delta rho squared, should be given in [1/m\super 2\nosupersub ].\

\i \

\i0 If, on the other hand, the intensity is in relative units, or if the size distribution can be in relative volume fraction, the units do not matter much. They should be consistent, but q can then be given in 1/nm, and the size bounds likewise in nm. The resulting distribution will then have the same units.\
\
The most straightforward way of fitting is by running:\
-->\

\f1 Result=Analyze_1D(q,I,E)\

\f0 <--\
Which after a minute or so (or about five minutes for the provided extended dataset on an Intel i7 at 1.8 GHz (MacBook Air)) will result in a dictionary called Result with all the fitting details in it. \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\i\fs32 \cf0 2. Plotting the result\

\i0\fs24 The result can be visualised using the built-in plotting function, which puts the data, its fit and the resulting size distribution alongside one another. This can be automatically started by using the option Plot=True in the Analyze_1D code, but can also be run separately. To plot, simply type:\
-->\

\f1 McPlot(q,I,E,Result)\

\f0 <--\
Which should give you the plot shown in test_data.pdf:\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f2 \cf0 {{\NeXTGraphic test_data.png \width20162 \height10081
}¬}
\f0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 The left-hand plot shows the data in black with error bars showing the uncertainty "E", the MC fit in red, and a green line indicating the fitted background level. The width of the green line also serves to indicate the fitting limits in q, and the background value is furthermore indicated in the legend.\
\
The right-hand plot shows the resulting volume-weighted size histogram, with uncertainties on the bars, and the red dashed line indicating the minimum level required for each bin to contribute a measurable amount (i.e. more than the uncertainty) to the scattering pattern.\
\
As is clear from the vertical axis on that plot, the partial volume fractions are unrealistic if the scattering contrast has not been set. One may also want to rebin the plot in fewer bins to reduce the relative uncertainties on the bins. \
\

\i\fs32 3. Rebinning the result\

\i0\fs24 These things can be achieved through rebinning of the result. The rebinning process takes similar arguments as Analyze_1D, and we can thus rebin and replot using (with empty line delimiting the for-loop):\
-->\

\f1 B = observability3(q,I,E,Rrep=Result['Rrep'],Rpfactor=0.5,Histbins=15,Histscale='log',drhosqr=1.e29)\
#copy all content of the result of observability3 to the output matrix\
for keyname in B.keys():\
Result[keyname] = B[keyname]\
\
McPlot(q,I,E,Result)
\f0 \
<--\
This should give the following figure (as shown in 'test_data_plot2.pdf'):\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f2 \cf0 {{\NeXTGraphic test_data_plot2.png \width20162 \height10081
}¬}
\f0\i\fs32 \

\i0\fs24 This plot shows more reasonable values for the relative volume fraction, the total volume fraction can be calculated from the 100 repetitions using:\
-->\

\f1 numpy.mean(Result['Vft'])\

\f0 <--\
which should result in about 15%. \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\i\fs32 \cf0 3.5 Everything in one step\

\i0\fs24 If you have a reasonable idea about what you want to do:\
\pard\tx220\tx720\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li720\fi-720\pardirnatural
\ls1\ilvl0\cf0 {\listtext	1.	}fit to within a chi-squared of 5.\
{\listtext	2.	}Only 25 repetitions\
{\listtext	3.	}Radius size bounds of [1e-10,2e-8] (it is not recommended to use '0' as starting point especially when using log-scaled histogram bins, but also because such sized scatterers are unphysical)\
{\listtext	4.	}q-limits between 2e8 and 1e10 reciprocal meters (0.2 and 10 reciprocal nanometers or 0.02 and 1 reciprocal \'e5ngstr\'f6m)\
{\listtext	5.	}A scattering contrast of 5e29 m\super -2\nosupersub  \
{\listtext	6.	}80 bins, linearly scaled\
{\listtext	7.	}using 100 sphere contributions\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
(there are more options but I am running out of ideas here:)\
Then you can do this in one step (with plotting) using:\
-->\

\f1 Result=Analyze_1D(q,I,E,Convcrit=5.,Nreps=25,Bounds=[1e-10,2e-8],qlims=[2e8,1e10],drhosqr=5.e29,Histbins=80,Histscale='lin',Nsph=100,Plot=True)\

\f0 <--\
Which returns a plot that looks a little wonky (given the low convergence criterion restrictions (the higher Convcrit, the more relaxed the criterion). But is otherwise perfectly valid (test_data_plot3.pdf):\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f2 \cf0 {{\NeXTGraphic test_data_plot3.png \width20162 \height10081
}¬}
\f0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural
\cf0 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\i\fs32 \cf0 4. Exporting the result\

\i0\fs24 At this point it may be a good idea to get the histogram data out of python and into another plotting program. You can export whatever information you want, but to get a useful set of four columns indicating left bin edge, bin width, bin value (height) and bin uncertainty (standard deviation), you can use:\
-->\

\f1 McCSV('hist.csv',Result['Hx'],Result['Hwidth'],Result['Hmean'],Result['Hstd'])\

\f0 <--\
Which writes just that to a file named 'hist.csv', semicolon delimited. It actually contains one more bin edge, which is the trailing edge and is superfluous. \
\

\i\fs32 5. What's next?\

\i0\fs24 If you have the ability and interest in improving the code, please consider joining the development effort, which will work on making the code object-oriented, including more shapes besides spheres, and adding slit-smearing options.\
\
If you have more questions that are not answered in either 1) the paper, 2) the code, and 3) this document, feel free to send me an e-mail which you can find on the http://lookingatnothing.com/ weblog.\
\
Good luck!
\i\fs32 \

\i0\fs24 \
\
}